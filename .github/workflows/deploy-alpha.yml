name: Alpha ë°°í¬

on:
  workflow_dispatch:
    inputs:
      deployment_phase:
        description: 'ì•± ë°°í¬ ë‹¨ê³„ (ê¸°ë³¸ê°’: alpha). alpha, beta, production ì¤‘ ì„ íƒ. ì´ì™¸ì˜ ê°’ì€ í—ˆìš©ë˜ì§€ ì•ŠìŒ.'
        required: false
        type: string
        default: 'alpha'
      aws_region:
        description: 'AWS ë¦¬ì „ (ê¸°ë³¸ê°’: ap-northeast-2)'
        required: false
        type: choice
        options:
          - ap-northeast-2
          - us-east-1
          - us-west-2
          - eu-west-1
          - ap-southeast-1
        default: 'ap-northeast-2'
      root_domain:
        description: 'ë£¨íŠ¸ ë„ë©”ì¸ (ì˜ˆ: ig-pilot.com)'
        required: false
        type: string
        default: 'ig-pilot.com'
      image_name:
        description: 'Docker ì´ë¯¸ì§€ ì´ë¦„ (ê¸°ë³¸ê°’: repository ì´ë¦„)'
        required: false
        type: string
      container_port:
        description: 'ì»¨í…Œì´ë„ˆ í¬íŠ¸ ë²ˆí˜¸ (ê¸°ë³¸ê°’: 8501)'
        required: false
        type: string
        default: '8501'
      health_check_path:
        description: 'Health check endpoint ê²½ë¡œ (ê¸°ë³¸ê°’: /api/health)'
        required: false
        type: string
        default: '/api/health'
      ecr_base_name:
        description: 'ECR ê¸°ë³¸ ê²½ë¡œ (ê¸°ë³¸ê°’: aws-deploy-wizard)'
        required: false
        type: string
        default: 'aws-deploy-wizard'
      ecs_cluster_base_name:
        description: 'ECS Cluster ì´ë¦„ (ê¸°ë³¸ê°’: aws-deploy-wizard)'
        required: false
        type: string
        default: 'aws-deploy-wizard'
      secrets_manager_passwords_set_name:
        description: 'Secrets Manager ë³´ì•ˆ ì•”í˜¸ ì´ë¦„ (ê¸°ë³¸ê°’: prod/ignite-pilot/postgresInfo2, ê¶Œì¥ íŒ¨í„´: {phase}/{application}/{secretName})'
        required: false
        type: string
        default: 'prod/ignite-pilot/postgresInfo2'
      task_cpu:
        description: 'ECS Task CPU ì„¤ì • (ê¸°ë³¸ê°’: 512 = 0.5 vCPU)'
        required: false
        type: string
        default: '512'
      task_memory:
        description: 'ECS Task Memory ì„¤ì • (ê¸°ë³¸ê°’: 1024 MB)'
        required: false
        type: string
        default: '1024'
      dockerfile_path:
        description: 'Dockerfile ê²½ë¡œ (ê¸°ë³¸ê°’: Dockerfile)'
        required: false
        type: string
        default: 'Dockerfile'
      build_context:
        description: 'Docker ë¹Œë“œ ì»¨í…ìŠ¤íŠ¸ ê²½ë¡œ (ê¸°ë³¸ê°’: .)'
        required: false
        type: string
        default: '.'
      target_platform:
        description: 'íƒ€ê²Ÿ í”Œë«í¼ ì•„í‚¤í…ì²˜ (ê¸°ë³¸ê°’: linux/amd64)'
        required: false
        type: string
        default: 'linux/amd64'
      ecs_desired_count:
        description: 'ECS Service ì‹¤í–‰í•  Task ê°œìˆ˜ (ê¸°ë³¸ê°’: 1)'
        required: false
        type: number
        default: 1
      assign_public_ip:
        description: 'ECS Taskì— í¼ë¸”ë¦­ IP í• ë‹¹ ì—¬ë¶€ (ê¸°ë³¸ê°’: ENABLED)'
        required: false
        type: choice
        options:
          - ENABLED
          - DISABLED
        default: 'ENABLED'
      health_check_interval:
        description: 'Health check ê°„ê²©(ì´ˆ) (ê¸°ë³¸ê°’: 30)'
        required: false
        type: number
        default: 30
      health_check_timeout:
        description: 'Health check íƒ€ì„ì•„ì›ƒ(ì´ˆ) (ê¸°ë³¸ê°’: 5)'
        required: false
        type: number
        default: 5
      healthy_threshold:
        description: 'Healthy íŒì • ì„ê³„ê°’ (ê¸°ë³¸ê°’: 2)'
        required: false
        type: number
        default: 2
      unhealthy_threshold:
        description: 'Unhealthy íŒì • ì„ê³„ê°’ (ê¸°ë³¸ê°’: 2)'
        required: false
        type: number
        default: 2
      # === Tier 3: ê³ ê¸‰ ì„¤ì • ===
      ecs_stabilization_timeout:
        description: 'ECS ì„œë¹„ìŠ¤ ì•ˆì •í™” ìµœëŒ€ ëŒ€ê¸° ì‹œê°„(ì´ˆ) (ê¸°ë³¸ê°’: 600 = 10ë¶„)'
        required: false
        type: number
        default: 600
      log_retention_days:
        description: 'CloudWatch ë¡œê·¸ ë³´ê´€ ê¸°ê°„(ì¼) (ê¸°ë³¸ê°’: 7, 0=ë¬´ì œí•œ)'
        required: false
        type: choice
        options:
          - '0'
          - '1'
          - '3'
          - '5'
          - '7'
          - '14'
          - '30'
          - '60'
          - '90'
          - '120'
          - '150'
          - '180'
          - '365'
          - '400'
          - '545'
          - '731'
          - '1827'
          - '3653'
        default: '7'

# ê³µí†µ í™˜ê²½ ë³€ìˆ˜
env:
  AWS_REGION: ${{ inputs.aws_region }}
  ROOT_DOMAIN: ${{ inputs.root_domain }}

jobs:
  ## Docker image ë¹Œë“œ: ì• í”Œë¦¬ì¼€ì´ì…˜ì„ íŒ¨í‚¤ì§•í•©ë‹ˆë‹¤.
  build-docker-image:
    runs-on: ubuntu-latest
    environment: ${{ inputs.deployment_phase }}
    permissions:
      id-token: write
      contents: read
    outputs:
      image_name: ${{ steps.set-image-name.outputs.image_name }}
      image_tag: ${{ steps.set-image-name.outputs.image_tag }}

    steps:
      - name: ì½”ë“œ ì²´í¬ì•„ì›ƒ
        uses: actions/checkout@v4

      - name: ì• í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬ ë‹¨ê³„ ê²€ì¦
        run: |
          if [ ${{ inputs.deployment_phase }} != "alpha" ] && [ ${{ inputs.deployment_phase }} != "beta" ] && [ ${{ inputs.deployment_phase }} != "production" ]; then
            echo "âŒ ì˜¤ë¥˜: ì˜ëª»ëœ deployment_phase ê°’ì…ë‹ˆë‹¤. í—ˆìš©ë˜ëŠ” ê°’ì€ 'alpha', 'beta', 'production' ì…ë‹ˆë‹¤."
            exit 1
          fi

      - name: ì´ë¯¸ì§€ ì´ë¦„ ë° íƒœê·¸ ì„¤ì •
        id: set-image-name
        run: |
          # Inputìœ¼ë¡œ ì´ë¯¸ì§€ ì´ë¦„ì´ ì œê³µë˜ì—ˆìœ¼ë©´ ì‚¬ìš©, ì•„ë‹ˆë©´ repository ì´ë¦„ ì‚¬ìš©
          if [ -n "${{ inputs.image_name }}" ]; then
            IMAGE_NAME="${{ inputs.image_name }}"
          else
            IMAGE_NAME="${{ github.event.repository.name }}"
          fi

          # íƒœê·¸ëŠ” git commit SHAì˜ ì§§ì€ ë²„ì „ ì‚¬ìš©
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_TAG_SHORT="${IMAGE_TAG:0:7}"

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG_SHORT}" >> $GITHUB_OUTPUT

          echo "ğŸ“¦ Docker ì´ë¯¸ì§€ ì´ë¦„: ${IMAGE_NAME}"
          echo "ğŸ·ï¸  Docker ì´ë¯¸ì§€ íƒœê·¸: ${IMAGE_TAG_SHORT}"

      - name: Docker image ìƒì„±(ì• í”Œë¦¬ì¼€ì´ì…˜ íŒ¨í‚¤ì§•)   # Target ë°°í¬í™˜ê²½ì— ë”°ë¼ ì•„í‚¤í…ì³ ëª…ì‹œ í•„ìš”í•  ìˆ˜ë„ ìˆìŒ
        run: |
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          IMAGE_TAG="${{ steps.set-image-name.outputs.image_tag }}"

          echo "ğŸ”¨ Docker ì´ë¯¸ì§€ ë¹Œë“œ ì‹œì‘..."
          echo "ì´ë¯¸ì§€: ${IMAGE_NAME}:${IMAGE_TAG}"

          # Docker ì´ë¯¸ì§€ ë¹Œë“œ
          docker build \
            --tag "${IMAGE_NAME}:${IMAGE_TAG}" \
            --tag "${IMAGE_NAME}:latest" \
            --file ${{ inputs.dockerfile_path }} \
            ${{ inputs.build_context }}

          echo "âœ… Docker ì´ë¯¸ì§€ ë¹Œë“œ ì™„ë£Œ"

      - name: ìƒì„±í•œ Docker image ê²€ì¦
        run: |
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          IMAGE_TAG="${{ steps.set-image-name.outputs.image_tag }}"

          echo "ğŸ” Docker ì´ë¯¸ì§€ ê²€ì¦ ì¤‘..."

          # ì´ë¯¸ì§€ ì¡´ì¬ í™•ì¸
          if ! docker images "${IMAGE_NAME}:${IMAGE_TAG}" --format "{{.Repository}}:{{.Tag}}" | grep -q "${IMAGE_NAME}:${IMAGE_TAG}"; then
            echo "âŒ ì˜¤ë¥˜: Docker ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (${IMAGE_NAME}:${IMAGE_TAG})"
            echo ""
            echo "ì‚¬ìš© ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ëª©ë¡:"
            docker images "${IMAGE_NAME}" --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}" || true
            exit 1
          fi

          echo "âœ“ ì´ë¯¸ì§€ ì¡´ì¬ í™•ì¸ ì™„ë£Œ"

          # ì´ë¯¸ì§€ ìƒì„¸ ì •ë³´ í™•ì¸
          echo ""
          echo "=== Docker ì´ë¯¸ì§€ ì •ë³´ ==="
          docker images "${IMAGE_NAME}" --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"

          echo ""
          echo "=== ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„° ==="
          docker inspect "${IMAGE_NAME}:${IMAGE_TAG}" --format='
          - ìƒì„± ì‹œê°„: {{.Created}}
          - ì•„í‚¤í…ì²˜: {{.Architecture}}
          - OS: {{.Os}}
          - í¬ê¸°: {{.Size}} bytes
          - Exposed Ports: {{.Config.ExposedPorts}}
          - Entrypoint: {{.Config.Entrypoint}}
          - Cmd: {{.Config.Cmd}}'

          echo ""
          echo "âœ… Docker ì´ë¯¸ì§€ ê²€ì¦ ì™„ë£Œ"

  ## AWS Infrastructure ë°°í¬: í•„ìš”í•œ ì¸í”„ë¼ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ì¤‘ë³µ ë°°í¬ëœ ì¸í”„ë¼ê°€ ìˆë‹¤ë©´, ê±´ë„ˆëœë‹ˆë‹¤.
  deploy-infrastructure-if-necessary:
    needs: build-docker-image
    runs-on: ubuntu-latest
    environment: ${{ inputs.deployment_phase }}
    permissions:
      id-token: write
      contents: read
    outputs:
      service_name: ${{ steps.set-outputs.outputs.service_name }}
      cluster_name: ${{ steps.set-outputs.outputs.cluster_name }}
      application_url: ${{ steps.set-outputs.outputs.application_url }}

    steps:
      - name: ì½”ë“œ ì²´í¬ì•„ì›ƒ
        uses: actions/checkout@v4

      - name: AWS ë¡œê·¸ì¸ ì •ë³´ ì •ì˜
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      # ë„ë©”ì¸ ì ‘ê·¼ ì¸ì¦ì„œ ìƒì„±ì„ ìœ„í•œ ì‚¬ì „ ì‘ì—…
      # ë„ë©”ì¸ ìƒì„±ì€ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ë¯€ë¡œ, ìµœëŒ€í•œ ë¹¨ë¦¬ ì§„í–‰í•˜ê³  ìµœì¢… ê²€ì¦ ë‹¨ê³„ì—ì„œ í™•ì¸í•´ ë¹Œë“œ ì‹œê°„ì„ ì¤„ì…ë‹ˆë‹¤.
      - name: Route53 Hosted Zone í™•ì¸
        run: |
          ROOT_DOMAIN="${{ env.ROOT_DOMAIN }}"

          echo "=== Route53 Hosted Zone í™•ì¸ ==="
          echo "ë„ë©”ì¸: ${ROOT_DOMAIN}"
          echo ""

          # Hosted Zone ì¡´ì¬ í™•ì¸
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones \
            --query "HostedZones[?Name=='${ROOT_DOMAIN}.'].Id" \
            --output text 2>/dev/null | cut -d'/' -f3)

          if [ -n "$HOSTED_ZONE_ID" ]; then
            echo "âœ“ ê¸°ì¡´ Hosted Zone ì‚¬ìš©: ${HOSTED_ZONE_ID}"
          else
            echo "Hosted Zone ìƒì„± ì¤‘: ${ROOT_DOMAIN}"

            # Caller Reference (ê³ ìœ  ì‹ë³„ì)
            CALLER_REF="github-actions-$(date +%s)"

            HOSTED_ZONE_ID=$(aws route53 create-hosted-zone \
              --name "${ROOT_DOMAIN}" \
              --caller-reference "${CALLER_REF}" \
              --hosted-zone-config Comment="Created by GitHub Actions" \
              --query 'HostedZone.Id' \
              --output text | cut -d'/' -f3)

            echo "âœ“ Hosted Zone ìƒì„± ì™„ë£Œ: ${HOSTED_ZONE_ID}"
          fi

          echo ""
          echo "HOSTED_ZONE_ID=${HOSTED_ZONE_ID}" >> $GITHUB_ENV

      # HTTPSë¥¼ ìœ„í•œ SSL/TLS ì¸ì¦ì„œ ìƒì„±
      - name: Amazon Certificate Manager ìš© ì¸ì¦ì„œ ìƒì„±
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"
          ROOT_DOMAIN="${{ env.ROOT_DOMAIN }}"

          echo "=== ACM ì¸ì¦ì„œ í™•ì¸ ==="

          # ë„ë©”ì¸ ì„¤ì •
          if [ "$DEPLOYMENT_PHASE" = "production" ]; then
            WILDCARD_DOMAIN="*.${IMAGE_NAME}.${ROOT_DOMAIN}"
            DOMAIN="${IMAGE_NAME}.${ROOT_DOMAIN}"
          else
            WILDCARD_DOMAIN="*.${DEPLOYMENT_PHASE}.${IMAGE_NAME}.${ROOT_DOMAIN}"
            DOMAIN="${DEPLOYMENT_PHASE}.${IMAGE_NAME}.${ROOT_DOMAIN}"
          fi

          echo "ì™€ì¼ë“œì¹´ë“œ ë„ë©”ì¸: ${WILDCARD_DOMAIN}"
          echo "ë£¨íŠ¸ ë„ë©”ì¸: ${DOMAIN}"
          echo ""

          # ê¸°ì¡´ ì¸ì¦ì„œ ê²€ìƒ‰ (ISSUED ë˜ëŠ” PENDING_VALIDATION ìƒíƒœ)
          CERTIFICATE_ARN=""
          CERT_LIST=$(aws acm list-certificates \
            --certificate-statuses ISSUED PENDING_VALIDATION \
            --region ap-northeast-2 \
            --query 'CertificateSummaryList[*].CertificateArn' \
            --output text)

          for CERT_ARN in $CERT_LIST; do
            # ì¸ì¦ì„œ ìƒì„¸ ì •ë³´ ì¡°íšŒ
            CERT_DETAIL=$(aws acm describe-certificate \
              --certificate-arn "$CERT_ARN" \
              --region ap-northeast-2 \
              --output json)

            CERT_DOMAIN=$(echo "$CERT_DETAIL" | jq -r '.Certificate.DomainName')
            SAN_LIST=$(echo "$CERT_DETAIL" | jq -r '.Certificate.SubjectAlternativeNames[]')
            CERT_STATUS=$(echo "$CERT_DETAIL" | jq -r '.Certificate.Status')

            # ë„ë©”ì¸ ì¼ì¹˜ í™•ì¸
            if [ "$CERT_DOMAIN" = "$WILDCARD_DOMAIN" ] && echo "$SAN_LIST" | grep -q "$DOMAIN"; then
              echo "âœ“ ê¸°ì¡´ ì¸ì¦ì„œ ë°œê²¬: $CERT_ARN"
              echo "  ìƒíƒœ: $CERT_STATUS"
              CERTIFICATE_ARN="$CERT_ARN"
              break
            fi
          done

          # ì¸ì¦ì„œê°€ ì—†ìœ¼ë©´ ìƒì„±
          if [ -z "$CERTIFICATE_ARN" ]; then
            echo "ê¸°ì¡´ ì¸ì¦ì„œ ì—†ìŒ - ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤..."

            # ACM ì¸ì¦ì„œ ìš”ì²­
            echo "ACM ì¸ì¦ì„œ ìš”ì²­ ì¤‘..."
            CERTIFICATE_ARN=$(aws acm request-certificate \
              --domain-name "${WILDCARD_DOMAIN}" \
              --subject-alternative-names "${DOMAIN}" \
              --validation-method DNS \
              --region ap-northeast-2 \
              --query 'CertificateArn' \
              --output text)

            echo "âœ“ ì¸ì¦ì„œ ìš”ì²­ ì™„ë£Œ: ${CERTIFICATE_ARN}"
          fi

          echo ""
          echo "CERTIFICATE_ARN=${CERTIFICATE_ARN}" >> $GITHUB_ENV
          echo "âœ“ ì¸ì¦ì„œ ARN: ${CERTIFICATE_ARN}"

      - name: ACM DNS ê²€ì¦ ë ˆì½”ë“œë¥¼ Route53ì— ì¶”ê°€
        run: |
          CERTIFICATE_ARN="${{ env.CERTIFICATE_ARN }}"
          HOSTED_ZONE_ID="${{ env.HOSTED_ZONE_ID }}"

          echo "=== ACM DNS ê²€ì¦ ë ˆì½”ë“œ ìƒì„± ==="
          echo "ì¸ì¦ì„œ ARN: ${CERTIFICATE_ARN}"
          echo "Hosted Zone ID: ${HOSTED_ZONE_ID}"
          echo ""

          # ì¸ì¦ì„œ ìƒíƒœ í™•ì¸
          CERT_STATUS=$(aws acm describe-certificate \
            --certificate-arn "${CERTIFICATE_ARN}" \
            --region ap-northeast-2 \
            --query 'Certificate.Status' \
            --output text)

          echo "ì¸ì¦ì„œ ìƒíƒœ: ${CERT_STATUS}"

          # ISSUED ìƒíƒœë©´ ì´ë¯¸ ê²€ì¦ ì™„ë£Œ
          if [ "$CERT_STATUS" = "ISSUED" ]; then
            echo "âœ“ ì¸ì¦ì„œê°€ ì´ë¯¸ ë°œê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤ (DNS ë ˆì½”ë“œ ì¶”ê°€ ë¶ˆí•„ìš”)"
            exit 0
          fi

          # DNS ê²€ì¦ ë ˆì½”ë“œê°€ ìƒì„±ë  ë•Œê¹Œì§€ ëŒ€ê¸° (ìµœëŒ€ 60ì´ˆ)
          echo ""
          echo "DNS ê²€ì¦ ë ˆì½”ë“œ ëŒ€ê¸° ì¤‘..."
          for i in {1..12}; do
            sleep 5
            VALIDATION_RECORDS=$(aws acm describe-certificate \
              --certificate-arn "${CERTIFICATE_ARN}" \
              --region ap-northeast-2 \
              --query 'Certificate.DomainValidationOptions[0].ResourceRecord' \
              --output json)

            if [ "$VALIDATION_RECORDS" != "null" ]; then
              echo "âœ“ ê²€ì¦ ë ˆì½”ë“œ ë°œê²¬ (${i}íšŒ ì‹œë„)"
              break
            fi
            echo "  ëŒ€ê¸° ì¤‘... (${i}íšŒ ì‹œë„)"
          done

          if [ "$VALIDATION_RECORDS" = "null" ]; then
            echo "âœ— ê²€ì¦ ë ˆì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
            exit 1
          fi

          # DNS ê²€ì¦ ë ˆì½”ë“œë¥¼ Route53ì— ì¶”ê°€
          echo ""
          echo "Route53ì— DNS ê²€ì¦ ë ˆì½”ë“œ ì¶”ê°€ ì¤‘..."

          VALIDATION_OPTIONS=$(aws acm describe-certificate \
            --certificate-arn "${CERTIFICATE_ARN}" \
            --region ap-northeast-2 \
            --query 'Certificate.DomainValidationOptions' \
            --output json)

          echo "$VALIDATION_OPTIONS" | jq -c '.[]' | while read -r option; do
            RECORD_NAME=$(echo "$option" | jq -r '.ResourceRecord.Name')
            RECORD_VALUE=$(echo "$option" | jq -r '.ResourceRecord.Value')
            RECORD_TYPE=$(echo "$option" | jq -r '.ResourceRecord.Type')

            if [ "$RECORD_NAME" != "null" ]; then
              echo "  DNS ë ˆì½”ë“œ ì¶”ê°€: ${RECORD_NAME} (${RECORD_TYPE})"

              aws route53 change-resource-record-sets \
                --hosted-zone-id "${HOSTED_ZONE_ID}" \
                --change-batch "{
                  \"Changes\": [{
                    \"Action\": \"UPSERT\",
                    \"ResourceRecordSet\": {
                      \"Name\": \"${RECORD_NAME}\",
                      \"Type\": \"${RECORD_TYPE}\",
                      \"TTL\": 300,
                      \"ResourceRecords\": [{\"Value\": \"${RECORD_VALUE}\"}]
                    }
                  }]
                }" > /dev/null

              echo "  âœ“ DNS ë ˆì½”ë“œ ì¶”ê°€ ì™„ë£Œ"
            fi
          done

          echo ""
          echo "âœ“ DNS ê²€ì¦ ë ˆì½”ë“œ ì¶”ê°€ ì™„ë£Œ"
          echo "ğŸ’¡ ACM ì¸ì¦ì„œëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ê²€ì¦ë©ë‹ˆë‹¤ (5-30ë¶„ ì†Œìš”)"

      - name: ECR ìƒì„±
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          REPOSITORY_NAME="${{ inputs.ecr_base_name }}/${IMAGE_NAME}"

          echo "=== Elastic Container Repository í™•ì¸ ==="
          echo "Repository ì´ë¦„: ${REPOSITORY_NAME}"
          echo ""

          # ë¦¬í¬ì§€í† ë¦¬ ì¡´ì¬ í™•ì¸
          if aws ecr describe-repositories --repository-names "${REPOSITORY_NAME}" --region ap-northeast-2 >/dev/null 2>&1; then
            echo "âœ“ ê¸°ì¡´ ECR ì‚¬ìš©: ${REPOSITORY_NAME}"
            REPOSITORY_URI=$(aws ecr describe-repositories --repository-names "${REPOSITORY_NAME}" --region ap-northeast-2 --query 'repositories[0].repositoryUri' --output text)
            echo "  URI: ${REPOSITORY_URI}"
          else
            # ë¦¬í¬ì§€í† ë¦¬ ìƒì„±
            echo "ECR ìƒì„± ì¤‘: ${REPOSITORY_NAME}"
            REPOSITORY_URI=$(aws ecr create-repository \
              --repository-name "${REPOSITORY_NAME}" \
              --region ap-northeast-2 \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE \
              --query 'repository.repositoryUri' \
              --output text)
            echo "âœ“ ECR ìƒì„± ì™„ë£Œ: ${REPOSITORY_URI}"
          fi

          echo ""
          echo "REPOSITORY_URI=${REPOSITORY_URI}" >> $GITHUB_ENV

      - name: ë¹Œë“œí•œ Docker ì´ë¯¸ì§€ í‘¸ì‹œ
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          IMAGE_TAG="${{ needs.build-docker-image.outputs.image_tag }}"
          REPOSITORY_URI="${{ env.REPOSITORY_URI }}"

          echo "=== Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ ==="
          echo "ECR URI: ${REPOSITORY_URI}"
          echo "ì´ë¯¸ì§€ íƒœê·¸: ${IMAGE_TAG}, latest"
          echo ""

          # ECR ë¡œê·¸ì¸
          echo "ECR ì¸ì¦ ì¤‘..."
          aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin ${REPOSITORY_URI%%/*}

          # Docker ì´ë¯¸ì§€ ë¹Œë“œ (ECS Fargate ìš”êµ¬ì‚¬í•­)
          echo "Docker ì´ë¯¸ì§€ ë¹Œë“œ ì¤‘ (${{ inputs.target_platform }})..."
          docker build --platform ${{ inputs.target_platform }} \
            -t ${REPOSITORY_URI}:${IMAGE_TAG} \
            -t ${REPOSITORY_URI}:latest \
            -f ${{ inputs.dockerfile_path }} \
            ${{ inputs.build_context }}

          # ECRì— í‘¸ì‹œ
          echo ""
          echo "ECRì— í‘¸ì‹œ ì¤‘..."
          docker push ${REPOSITORY_URI}:${IMAGE_TAG}
          docker push ${REPOSITORY_URI}:latest

          echo ""
          echo "âœ“ Docker ì´ë¯¸ì§€ í‘¸ì‹œ ì™„ë£Œ"
          echo "  - ${REPOSITORY_URI}:${IMAGE_TAG}"
          echo "  - ${REPOSITORY_URI}:latest"

      - name: ECS Cluster ìƒì„±
        run: |
          CLUSTER_NAME="${{ inputs.ecs_cluster_base_name }}"

          echo "=== ECS Cluster í™•ì¸ ==="
          echo "Cluster ì´ë¦„: ${CLUSTER_NAME}"
          echo ""

          # Cluster ì¡´ì¬ í™•ì¸
          CLUSTER_STATUS=$(aws ecs describe-clusters \
            --clusters "${CLUSTER_NAME}" \
            --region ap-northeast-2 \
            --query 'clusters[0].status' \
            --output text 2>/dev/null || echo "NONE")

          if [ "$CLUSTER_STATUS" = "ACTIVE" ]; then
            echo "âœ“ ê¸°ì¡´ ECS Cluster ì‚¬ìš©: ${CLUSTER_NAME}"
          elif [ "$CLUSTER_STATUS" = "NONE" ] || [ "$CLUSTER_STATUS" = "INACTIVE" ]; then
            # Cluster ìƒì„±
            echo "ECS Cluster ìƒì„± ì¤‘: ${CLUSTER_NAME}"
            aws ecs create-cluster \
              --cluster-name "${CLUSTER_NAME}" \
              --region ap-northeast-2 \
              --tags key=Name,value=${CLUSTER_NAME} key=ManagedBy,value=github-actions \
              > /dev/null

            echo "âœ“ ECS Cluster ìƒì„± ì™„ë£Œ: ${CLUSTER_NAME}"
          else
            echo "âš ï¸  Cluster ìƒíƒœ í™•ì¸ ë¶ˆê°€: ${CLUSTER_STATUS}"
          fi

          echo ""
          echo "CLUSTER_NAME=${CLUSTER_NAME}" >> $GITHUB_ENV

      # ECS Task ì‹¤í–‰ì„ ìœ„í•œ IAM ì—­í•  í™•ì¸
      - name: IAM Execution Role ìƒì„± ë° í™•ì¸
        run: |
          set -euo pipefail

          ROLE_NAME="ecsTaskExecutionRole"
          REGION="${{ env.AWS_REGION }}"
          
          echo "=== IAM Execution Role í™•ì¸ ==="
          echo "Role ì´ë¦„: ${ROLE_NAME}"
          echo ""
          
          TRUST_POLICY='{
            "Version": "2012-10-17",
            "Statement": [{
              "Effect": "Allow",
              "Principal": { "Service": "ecs-tasks.amazonaws.com" },
              "Action": "sts:AssumeRole"
            }]
          }'
          
          SECRETS_POLICY='{
            "Version": "2012-10-17",
            "Statement": [{
              "Effect": "Allow",
              "Action": "secretsmanager:GetSecretValue",
              "Resource": "arn:aws:secretsmanager:'"${REGION}"':*:secret:prod/ignite-pilot/*"
            }]
          }'
          
          # Role ì¡´ì¬ ì—¬ë¶€ í™•ì¸
          if aws iam get-role --role-name "${ROLE_NAME}" >/dev/null 2>&1; then
            echo "âœ“ ê¸°ì¡´ Execution Role ì‚¬ìš©: ${ROLE_NAME}"
          else
            echo "Execution Role ìƒì„± ì¤‘: ${ROLE_NAME}"
          
            aws iam create-role \
              --role-name "${ROLE_NAME}" \
              --assume-role-policy-document "${TRUST_POLICY}" \
              >/dev/null
          
            echo "âœ“ Role ìƒì„± ì™„ë£Œ"
          fi
          
          # Role ARN ì¡°íšŒ (ê³µí†µ)
          ROLE_ARN=$(aws iam get-role \
            --role-name "${ROLE_NAME}" \
            --query 'Role.Arn' \
            --output text)
          
          echo "âœ“ Execution Role ARN: ${ROLE_ARN}"
          
          # AWS ê´€ë¦¬í˜• ì •ì±… ì—°ê²° (ì¤‘ë³µ ì—°ê²° ì•ˆì „)
          aws iam attach-role-policy \
            --role-name "${ROLE_NAME}" \
            --policy-arn "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
          
          echo "âœ“ AmazonECSTaskExecutionRolePolicy ì—°ê²° ì™„ë£Œ"
          
          # Secrets Manager inline policy (í•­ìƒ ë³´ì¥)
          aws iam put-role-policy \
            --role-name "${ROLE_NAME}" \
            --policy-name "SecretsManagerAccess" \
            --policy-document "${SECRETS_POLICY}"
          
          echo "âœ“ Secrets Manager ì ‘ê·¼ ê¶Œí•œ ë³´ì¥ ì™„ë£Œ"
          
          echo ""
          echo "EXECUTION_ROLE_ARN=${ROLE_ARN}" >> "$GITHUB_ENV"

      # ECS Task ë¡œê·¸ ê¸°ë¡ ë° í™•ì¸ì„ ìœ„í•œ Log Group
      # Service (ì• í”Œë¦¬ì¼€ì´ì…˜) ë‹¨ìœ„ë¡œ Log Group ìƒì„± (AWS Best Practice)
      - name: CloudWatch Log Group í™•ì¸
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          CLUSTER_NAME="${{ inputs.ecs_cluster_base_name }}"
          LOG_GROUP="/ecs/${CLUSTER_NAME}/${IMAGE_NAME}"

          echo "=== CloudWatch Log Group í™•ì¸ ==="
          echo "Log Group: ${LOG_GROUP}"
          echo ""

          # Log Group ì¡´ì¬ í™•ì¸
          if aws logs describe-log-groups --log-group-name-prefix "${LOG_GROUP}" --region ap-northeast-2 | grep -q "${LOG_GROUP}"; then
            echo "âœ“ ê¸°ì¡´ Log Group ì‚¬ìš©: ${LOG_GROUP}"
          else
            echo "Log Group ìƒì„± ì¤‘: ${LOG_GROUP}"

            aws logs create-log-group \
              --log-group-name "${LOG_GROUP}" \
              --region ap-northeast-2

            echo "âœ“ Log Group ìƒì„± ì™„ë£Œ: ${LOG_GROUP}"
          fi

          # Log Group ë³´ê´€ ê¸°ê°„ ì„¤ì •
          RETENTION_DAYS=${{ inputs.log_retention_days }}
          if [ "$RETENTION_DAYS" != "0" ]; then
            echo "ë¡œê·¸ ë³´ê´€ ê¸°ê°„ ì„¤ì • ì¤‘: ${RETENTION_DAYS}ì¼"
            aws logs put-retention-policy \
              --log-group-name "${LOG_GROUP}" \
              --retention-in-days ${RETENTION_DAYS} \
              --region ap-northeast-2
            echo "âœ“ ë¡œê·¸ ë³´ê´€ ê¸°ê°„ ì„¤ì • ì™„ë£Œ"
          else
            echo "âœ“ ë¡œê·¸ ë³´ê´€ ê¸°ê°„: ë¬´ì œí•œ (ê¸°ë³¸ê°’)"
          fi

          echo ""
          echo "LOG_GROUP=${LOG_GROUP}" >> $GITHUB_ENV

      # ECS Task Definition ê´€ë¦¬ ì •ì±…:
      #  - ëª¨ë“  ë°°í¬ë§ˆë‹¤ ìƒˆë¡œìš´ Task Definition revision ìƒì„±
      #  - Alpha/Beta: latest íƒœê·¸ ì‚¬ìš©, force-new-deploymentë¡œ ì´ë¯¸ì§€ ê°±ì‹ 
      #  - Production: ì»¤ë°‹ í•´ì‹œ íƒœê·¸ ì‚¬ìš©, ìë™ìœ¼ë¡œ ìƒˆ revision ìƒì„±
      #  - ì´ë¥¼ í†µí•´ í•­ìƒ ìµœì‹  ì´ë¯¸ì§€ URIê°€ Task Definitionì— ë°˜ì˜ë¨
      - name: ECS Task Definition ë“±ë¡
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          IMAGE_TAG="${{ needs.build-docker-image.outputs.image_tag }}"
          REPOSITORY_URI="${{ env.REPOSITORY_URI }}"
          EXECUTION_ROLE_ARN="${{ env.EXECUTION_ROLE_ARN }}"
          LOG_GROUP="${{ env.LOG_GROUP }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"

          FAMILY="${IMAGE_NAME}-task"
          # Alpha/Beta í™˜ê²½ì€ latest íƒœê·¸ ì‚¬ìš© (IMAGE_TAG ë¬´ì‹œ)
          IMAGE_URI="${REPOSITORY_URI}:latest"
          CONTAINER_PORT=${{ inputs.container_port }}
          SECRET_NAME="${{ inputs.secrets_manager_passwords_set_name }}"

          echo "=== ECS Task Definition ë“±ë¡ ==="
          echo "Family: ${FAMILY}"
          echo "Image: ${IMAGE_URI}"
          echo "Port: ${CONTAINER_PORT}"
          echo ""

          # Secrets Managerì—ì„œ í‚¤ ëª©ë¡ ë™ì  ì¡°íšŒ
          echo "Secrets Manager í‚¤ ì¡°íšŒ ì¤‘..."
          SECRET_RESPONSE=$(aws secretsmanager get-secret-value \
            --secret-id "${SECRET_NAME}" \
            --region ap-northeast-2 \
            --output json 2>/dev/null || echo "{}")

          SECRET_JSON=$(echo "$SECRET_RESPONSE" | jq -r '.SecretString // "{}"')
          SECRET_ARN=$(echo "$SECRET_RESPONSE" | jq -r '.ARN // ""')

          # JSON í‚¤ ëª©ë¡ ì¶”ì¶œ ë° secrets í•„ë“œ ë™ì  ìƒì„± (jq í™œìš©)
          if [ "$SECRET_JSON" != "{}" ] && [ -n "$SECRET_ARN" ]; then
            echo "âœ“ Secret ë°œê²¬, ë™ì ìœ¼ë¡œ ë§¤í•‘ ìƒì„± ì¤‘..."
            echo "  Secret ARN: ${SECRET_ARN}"

            # jqë¥¼ ì‚¬ìš©í•˜ì—¬ secrets í•„ë“œ ìƒì„± (ì „ì²´ ARN ì‚¬ìš©)
            SECRETS_ARRAY=$(echo "$SECRET_JSON" | jq -c --arg arn "$SECRET_ARN" \
              '[keys[] | {name: ., valueFrom: ($arn + ":" + . + "::")}]')

            # ë§¤í•‘ëœ í‚¤ ê°œìˆ˜ ê³„ì‚°
            SECRET_COUNT=$(echo "$SECRETS_ARRAY" | jq 'length')
            echo "âœ“ Secrets í•„ë“œ ìƒì„± ì™„ë£Œ (${SECRET_COUNT}ê°œ í‚¤ ë§¤í•‘ë¨)"
          else
            echo "âš ï¸  Secretì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í™˜ê²½ë³€ìˆ˜ fallbackë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤."
            SECRETS_ARRAY="[]"
          fi

          # ë§¤í•‘ëœ í™˜ê²½ë³€ìˆ˜ í‚¤ ëª©ë¡ ì¶œë ¥. ë””ë²„ê¹… ëª©ì ìœ¼ë¡œ í™œìš©í•©ë‹ˆë‹¤.
          if [ "$SECRETS_ARRAY" != "[]" ]; then
            echo "ë§¤í•‘ëœ í™˜ê²½ë³€ìˆ˜ í‚¤:"
            echo "$SECRETS_ARRAY" | jq -r '.[].name' | sed 's/^/  - /'
          fi
          echo ""

          # Container Definitions ìƒì„± (jq í™œìš©ìœ¼ë¡œ ê°€ë…ì„± ë° ì•ˆì •ì„± í–¥ìƒ)
          CONTAINER_DEFS=$(jq -nc \
            --arg name "$IMAGE_NAME" \
            --arg image "$IMAGE_URI" \
            --argjson port "$CONTAINER_PORT" \
            --arg phase "$DEPLOYMENT_PHASE" \
            --arg log_group "$LOG_GROUP" \
            --argjson secrets "$SECRETS_ARRAY" \
            '[{
              name: $name,
              image: $image,
              portMappings: [{
                containerPort: $port,
                protocol: "tcp"
              }],
              environment: [
                {name: "ENVIRONMENT", value: $phase},
                {name: "PHASE", value: $phase}
              ],
              secrets: $secrets,
              logConfiguration: {
                logDriver: "awslogs",
                options: {
                  "awslogs-group": $log_group,
                  "awslogs-region": "ap-northeast-2",
                  "awslogs-stream-prefix": $name
                }
              },
              essential: true
            }]')

          # Task Definition í•­ìƒ ìƒˆë¡œ ë“±ë¡ (ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸ ë³´ì¥)
          echo "ìƒˆ Task Definition ë“±ë¡ ì¤‘..."
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --family "${FAMILY}" \
            --network-mode awsvpc \
            --requires-compatibilities FARGATE \
            --cpu ${{ inputs.task_cpu }} \
            --memory ${{ inputs.task_memory }} \
            --execution-role-arn "${EXECUTION_ROLE_ARN}" \
            --container-definitions "$CONTAINER_DEFS" \
            --region ap-northeast-2 \
            --tags key=Name,value=${FAMILY} key=Application,value=${IMAGE_NAME} key=ManagedBy,value=github-actions \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          REVISION=$(echo "${TASK_DEF_ARN}" | awk -F: '{print $NF}')

          echo "âœ“ Task Definition ë“±ë¡ ì™„ë£Œ: ${FAMILY}:${REVISION}"
          echo "  ARN: ${TASK_DEF_ARN}"
          echo "  Image: ${IMAGE_URI}"

          echo ""
          echo "TASK_DEFINITION_ARN=${TASK_DEF_ARN}" >> $GITHUB_ENV
          echo "CONTAINER_PORT=${CONTAINER_PORT}" >> $GITHUB_ENV

      - name: VPC ë° Subnet ì¡°íšŒ
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"

          echo "=== VPC ë° Subnet ì¡°íšŒ ==="

          # Default VPC ì¡°íšŒ
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --region ${REGION} \
            --query 'Vpcs[0].VpcId' \
            --output text)

          # Subnet ëª©ë¡ ì¡°íšŒ (ALBëŠ” ìµœì†Œ 2ê°œ AZ í•„ìš”, ê° AZë‹¹ 1ê°œ ì„œë¸Œë„·ë§Œ ì‚¬ìš©)
          # ê° Availability Zoneë³„ë¡œ ì²« ë²ˆì§¸ ì„œë¸Œë„·ë§Œ ì„ íƒ
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=${VPC_ID}" \
            --region ${REGION} \
            --query 'Subnets[].[AvailabilityZone,SubnetId]' \
            --output text | \
            sort | \
            awk '!seen[$1]++ {print $2}' | \
            tr '\n' ',' | \
            sed 's/,$//')

          echo "âœ“ VPC: ${VPC_ID}"
          echo "âœ“ Subnets: ${SUBNET_IDS}"

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "VPC_ID=${VPC_ID}" >> $GITHUB_ENV
          echo "SUBNET_IDS=${SUBNET_IDS}" >> $GITHUB_ENV

      - name: ALB Security Group ìƒì„±
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          VPC_ID="${{ env.VPC_ID }}"
          ALB_SG_NAME="${IMAGE_NAME}-alb-sg"

          echo "=== ALB Security Group ìƒì„± ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ ALB Security Group í™•ì¸
          ALB_SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=${ALB_SG_NAME}" "Name=vpc-id,Values=${VPC_ID}" \
            --region ${REGION} \
            --query 'SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$ALB_SG_ID"; then
            echo "âœ“ ê¸°ì¡´ ALB Security Group ì‚¬ìš©: ${ALB_SG_ID}"
          else
            # ALB Security Group ìƒì„±
            ALB_SG_ID=$(aws ec2 create-security-group \
              --group-name "${ALB_SG_NAME}" \
              --description "Security group for ${IMAGE_NAME} ALB" \
              --vpc-id "${VPC_ID}" \
              --region ${REGION} \
              --query 'GroupId' \
              --output text)

            # HTTP(80), HTTPS(443) ì¸ë°”ìš´ë“œ ê·œì¹™ ì¶”ê°€
            for PORT in 80 443; do
              aws ec2 authorize-security-group-ingress \
                --group-id "${ALB_SG_ID}" \
                --protocol tcp \
                --port ${PORT} \
                --cidr 0.0.0.0/0 \
                --region ${REGION} >/dev/null 2>&1 || true
            done

            echo "âœ“ ALB Security Group ìƒì„± ì™„ë£Œ: ${ALB_SG_ID}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "ALB_SECURITY_GROUP_ID=${ALB_SG_ID}" >> $GITHUB_ENV

      - name: ECS Service Security Group ìƒì„±
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          VPC_ID="${{ env.VPC_ID }}"
          ALB_SG_ID="${{ env.ALB_SECURITY_GROUP_ID }}"
          CONTAINER_PORT=${{ inputs.container_port }}
          ECS_SG_NAME="${IMAGE_NAME}-ecs-sg"

          echo "=== ECS Service Security Group ìƒì„± ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ ECS Security Group í™•ì¸
          ECS_SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=${ECS_SG_NAME}" "Name=vpc-id,Values=${VPC_ID}" \
            --region ${REGION} \
            --query 'SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$ECS_SG_ID"; then
            echo "âœ“ ê¸°ì¡´ ECS Security Group ì‚¬ìš©: ${ECS_SG_ID}"
          else
            # ECS Security Group ìƒì„±
            ECS_SG_ID=$(aws ec2 create-security-group \
              --group-name "${ECS_SG_NAME}" \
              --description "Security group for ${IMAGE_NAME} ECS Service" \
              --vpc-id "${VPC_ID}" \
              --region ${REGION} \
              --query 'GroupId' \
              --output text)

            # ALBë¡œë¶€í„° ì»¨í…Œì´ë„ˆ í¬íŠ¸ í—ˆìš©
            aws ec2 authorize-security-group-ingress \
              --group-id "${ECS_SG_ID}" \
              --protocol tcp \
              --port ${CONTAINER_PORT} \
              --source-group "${ALB_SG_ID}" \
              --region ${REGION} >/dev/null 2>&1 || true

            echo "âœ“ ECS Security Group ìƒì„± ì™„ë£Œ: ${ECS_SG_ID}"
            echo "  ALB SG (${ALB_SG_ID}) â†’ ECS SG (${ECS_SG_ID}):${CONTAINER_PORT}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "ECS_SECURITY_GROUP_ID=${ECS_SG_ID}" >> $GITHUB_ENV

      - name: Target Group ìƒì„±
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          VPC_ID="${{ env.VPC_ID }}"
          CONTAINER_PORT="${{ env.CONTAINER_PORT }}"
          HEALTH_CHECK_PATH="${{ inputs.health_check_path }}"
          TG_NAME="${IMAGE_NAME}-tg"

          echo "=== Target Group ìƒì„± ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ Target Group í™•ì¸
          TG_ARN=$(aws elbv2 describe-target-groups \
            --names "${TG_NAME}" \
            --region ${REGION} \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$TG_ARN"; then
            echo "âœ“ ê¸°ì¡´ Target Group ì‚¬ìš©: ${TG_ARN}"
          else
            # Target Group ìƒì„±
            TG_ARN=$(aws elbv2 create-target-group \
              --name "${TG_NAME}" \
              --protocol HTTP \
              --port ${CONTAINER_PORT} \
              --vpc-id "${VPC_ID}" \
              --target-type ip \
              --health-check-path "${HEALTH_CHECK_PATH}" \
              --health-check-interval-seconds ${{ inputs.health_check_interval }} \
              --health-check-timeout-seconds ${{ inputs.health_check_timeout }} \
              --healthy-threshold-count ${{ inputs.healthy_threshold }} \
              --unhealthy-threshold-count ${{ inputs.unhealthy_threshold }} \
              --region ${REGION} \
              --query 'TargetGroups[0].TargetGroupArn' \
              --output text)

            echo "âœ“ Target Group ìƒì„± ì™„ë£Œ: ${TG_ARN}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "TARGET_GROUP_ARN=${TG_ARN}" >> $GITHUB_ENV

      - name: Application Load Balancer ìƒì„±
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          SUBNET_IDS="${{ env.SUBNET_IDS }}"
          ALB_SG_ID="${{ env.ALB_SECURITY_GROUP_ID }}"
          ALB_NAME="${IMAGE_NAME}-alb"

          echo "=== Application Load Balancer ìƒì„± ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ ALB í™•ì¸
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --names "${ALB_NAME}" \
            --region ${REGION} \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$ALB_ARN"; then
            echo "âœ“ ê¸°ì¡´ ALB ì‚¬ìš©: ${ALB_ARN}"
          else
            # ALB ìƒì„±
            echo "ALB ìƒì„± ì¤‘..."
            ALB_ARN=$(aws elbv2 create-load-balancer \
              --name "${ALB_NAME}" \
              --subnets $(echo ${SUBNET_IDS} | tr ',' ' ') \
              --security-groups "${ALB_SG_ID}" \
              --scheme internet-facing \
              --type application \
              --ip-address-type ipv4 \
              --region ${REGION} \
              --tags Key=Name,Value=${ALB_NAME} Key=Application,Value=${IMAGE_NAME} Key=ManagedBy,Value=github-actions \
              --query 'LoadBalancers[0].LoadBalancerArn' \
              --output text)

            echo "âœ“ ALB ìƒì„± ì™„ë£Œ: ${ALB_ARN}"

            # ALB í™œì„±í™” ëŒ€ê¸° (ìµœëŒ€ 60ì´ˆ)
            echo "ALB í™œì„±í™” ëŒ€ê¸° ì¤‘..."
            for i in {1..12}; do
              STATE=$(aws elbv2 describe-load-balancers \
                --load-balancer-arns "${ALB_ARN}" \
                --region ${REGION} \
                --query 'LoadBalancers[0].State.Code' \
                --output text)

              if [ "$STATE" = "active" ]; then
                echo "âœ“ ALB í™œì„±í™” ì™„ë£Œ"
                break
              fi

              sleep 5
            done
          fi

          # ALB DNS ì´ë¦„ ì¡°íšŒ
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns "${ALB_ARN}" \
            --region ${REGION} \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "âœ“ ALB DNS: ${ALB_DNS}"

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "ALB_ARN=${ALB_ARN}" >> $GITHUB_ENV
          echo "ALB_DNS=${ALB_DNS}" >> $GITHUB_ENV

      - name: HTTPS Listener ìƒì„± (443 í¬íŠ¸)
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          ALB_ARN="${{ env.ALB_ARN }}"
          TARGET_GROUP_ARN="${{ env.TARGET_GROUP_ARN }}"
          CERTIFICATE_ARN="${{ env.CERTIFICATE_ARN }}"

          echo "=== HTTPS Listener ìƒì„± (443) ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ HTTPS Listener í™•ì¸
          LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn "${ALB_ARN}" \
            --region ${REGION} \
            --query 'Listeners[?Port==`443`].ListenerArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$LISTENER_ARN"; then
            echo "âœ“ ê¸°ì¡´ HTTPS Listener ì‚¬ìš©: ${LISTENER_ARN}"
          else
            # HTTPS Listener ìƒì„±
            LISTENER_ARN=$(aws elbv2 create-listener \
              --load-balancer-arn "${ALB_ARN}" \
              --protocol HTTPS \
              --port 443 \
              --certificates CertificateArn=${CERTIFICATE_ARN} \
              --default-actions Type=forward,TargetGroupArn=${TARGET_GROUP_ARN} \
              --region ${REGION} \
              --query 'Listeners[0].ListenerArn' \
              --output text)

            echo "âœ“ HTTPS Listener ìƒì„± ì™„ë£Œ: ${LISTENER_ARN}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "HTTPS_LISTENER_ARN=${LISTENER_ARN}" >> $GITHUB_ENV

      - name: HTTP Listener ìƒì„± (80 â†’ 443 ë¦¬ë‹¤ì´ë ‰íŠ¸)
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          ALB_ARN="${{ env.ALB_ARN }}"

          echo "=== HTTP Listener ìƒì„± (80 â†’ 443 ë¦¬ë‹¤ì´ë ‰íŠ¸) ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ HTTP Listener í™•ì¸
          HTTP_LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn "${ALB_ARN}" \
            --region ${REGION} \
            --query 'Listeners[?Port==`80`].ListenerArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$HTTP_LISTENER_ARN"; then
            echo "âœ“ ê¸°ì¡´ HTTP Listener ì‚¬ìš©: ${HTTP_LISTENER_ARN}"
          else
            # HTTP Listener ìƒì„± (HTTPSë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸)
            HTTP_LISTENER_ARN=$(aws elbv2 create-listener \
              --load-balancer-arn "${ALB_ARN}" \
              --protocol HTTP \
              --port 80 \
              --default-actions Type=redirect,RedirectConfig="{Protocol=HTTPS,Port=443,StatusCode=HTTP_301}" \
              --region ${REGION} \
              --query 'Listeners[0].ListenerArn' \
              --output text)

            echo "âœ“ HTTP Listener ìƒì„± ì™„ë£Œ (HTTPSë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸): ${HTTP_LISTENER_ARN}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "HTTP_LISTENER_ARN=${HTTP_LISTENER_ARN}" >> $GITHUB_ENV

          # ìµœì¢… ìš”ì•½ ì¶œë ¥
          echo ""
          echo "=========================================="
          echo "âœ“ ALB ì¸í”„ë¼ êµ¬ì„± ì™„ë£Œ"
          echo "  - ALB DNS: ${{ env.ALB_DNS }}"
          echo "  - Target Group: ${{ env.TARGET_GROUP_ARN }}"
          echo "=========================================="

      - name: ECS Service ë°°í¬
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"

          # ë³€ìˆ˜ ì´ˆê¸°í™”
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"
          CLUSTER_NAME="${{ env.CLUSTER_NAME }}"
          TASK_DEFINITION_ARN="${{ env.TASK_DEFINITION_ARN }}"
          TARGET_GROUP_ARN="${{ env.TARGET_GROUP_ARN }}"
          ECS_SG_ID="${{ env.ECS_SECURITY_GROUP_ID }}"
          SUBNET_IDS="${{ env.SUBNET_IDS }}"
          CONTAINER_PORT="${{ env.CONTAINER_PORT }}"
          SERVICE_NAME="${IMAGE_NAME}-service"

          echo "=== ECS Service ë°°í¬ ==="
          echo "Service: ${SERVICE_NAME}"
          echo "Cluster: ${CLUSTER_NAME}"
          echo "Deployment Phase: ${DEPLOYMENT_PHASE}"

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # Capacity Provider ì„¤ì • (alpha/beta: FARGATE_SPOT, production: FARGATE)
          if [ "$DEPLOYMENT_PHASE" = "production" ]; then
            CAPACITY_PROVIDER="FARGATE"
            FORCE_NEW_DEPLOYMENT=""
            echo "âœ“ Capacity Provider: FARGATE (On-Demand)"
          else
            CAPACITY_PROVIDER="FARGATE_SPOT"
            FORCE_NEW_DEPLOYMENT="--force-new-deployment"
            echo "âœ“ Capacity Provider: FARGATE_SPOT (latest íƒœê·¸, force deployment)"
          fi

          # ê¸°ì¡´ Service í™•ì¸
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster "${CLUSTER_NAME}" \
            --services "${SERVICE_NAME}" \
            --region ${REGION} \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "NONE")

          if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            # Service ì—…ë°ì´íŠ¸
            echo "ê¸°ì¡´ Service ì—…ë°ì´íŠ¸ ì¤‘..."
            aws ecs update-service \
              --cluster "${CLUSTER_NAME}" \
              --service "${SERVICE_NAME}" \
              --task-definition "${TASK_DEFINITION_ARN}" \
              --desired-count ${{ inputs.ecs_desired_count }} \
              --capacity-provider-strategy capacityProvider=${CAPACITY_PROVIDER},weight=1 \
              ${FORCE_NEW_DEPLOYMENT} \
              --region ${REGION} \
              --query 'service.serviceName' \
              --output text > /dev/null

            echo "âœ“ Service ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${SERVICE_NAME}"
          else
            # Service ìƒì„±
            echo "ìƒˆ Service ìƒì„± ì¤‘..."

            # Subnet IDsë¥¼ ë°°ì—´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (ì‰¼í‘œ â†’ ê³µë°±)
            SUBNET_ARRAY=$(echo ${SUBNET_IDS} | tr ',' ' ')

            aws ecs create-service \
              --cluster "${CLUSTER_NAME}" \
              --service-name "${SERVICE_NAME}" \
              --task-definition "${TASK_DEFINITION_ARN}" \
              --desired-count ${{ inputs.ecs_desired_count }} \
              --capacity-provider-strategy capacityProvider=${CAPACITY_PROVIDER},weight=1 \
              --network-configuration "awsvpcConfiguration={subnets=[${SUBNET_IDS}],securityGroups=[${ECS_SG_ID}],assignPublicIp=${{ inputs.assign_public_ip }}}" \
              --load-balancers "targetGroupArn=${TARGET_GROUP_ARN},containerName=${IMAGE_NAME},containerPort=${CONTAINER_PORT}" \
              --region ${REGION} \
              --tags key=Name,value=${SERVICE_NAME} key=Application,value=${IMAGE_NAME} key=ManagedBy,value=github-actions \
              --query 'service.serviceName' \
              --output text > /dev/null

            echo "âœ“ Service ìƒì„± ì™„ë£Œ: ${SERVICE_NAME}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "SERVICE_NAME=${SERVICE_NAME}" >> $GITHUB_ENV

      - name: Route 53 DNS ë ˆì½”ë“œ ìƒì„±
        id: set-outputs
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          ROOT_DOMAIN="${{ env.ROOT_DOMAIN }}"

          # ë³€ìˆ˜ ì´ˆê¸°í™”
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"
          HOSTED_ZONE_ID="${{ env.HOSTED_ZONE_ID }}"
          ALB_DNS="${{ env.ALB_DNS }}"
          ALB_ARN="${{ env.ALB_ARN }}"
          SERVICE_NAME="${{ env.SERVICE_NAME }}"
          CLUSTER_NAME="${{ env.CLUSTER_NAME }}"

          echo "=== Route 53 DNS ë ˆì½”ë“œ ìƒì„± ==="

          # ë„ë©”ì¸ ì´ë¦„ ì„¤ì •
          if [ "$DEPLOYMENT_PHASE" = "production" ]; then
            DOMAIN="${IMAGE_NAME}.${ROOT_DOMAIN}"
          else
            DOMAIN="${DEPLOYMENT_PHASE}.${IMAGE_NAME}.${ROOT_DOMAIN}"
          fi

          # ALBì˜ Hosted Zone ID ì¡°íšŒ (Alias ë ˆì½”ë“œì— í•„ìš”)
          ALB_HOSTED_ZONE_ID=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns "${ALB_ARN}" \
            --region ${REGION} \
            --query 'LoadBalancers[0].CanonicalHostedZoneId' \
            --output text)

          echo "ë„ë©”ì¸: ${DOMAIN}"
          echo "ALB DNS: ${ALB_DNS}"

          # DNS ë ˆì½”ë“œ UPSERT (ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸)
          # heredocìœ¼ë¡œ JSON ìƒì„± (íŒŒì‹± ì•ˆì „ì„± í–¥ìƒ)
          CHANGE_BATCH=$(cat <<EOFCHANGE
          {
            "Changes": [{
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "${DOMAIN}",
                "Type": "A",
                "AliasTarget": {
                  "HostedZoneId": "${ALB_HOSTED_ZONE_ID}",
                  "DNSName": "${ALB_DNS}",
                  "EvaluateTargetHealth": true
                }
              }
            }]
          }
          EOFCHANGE
          )

          aws route53 change-resource-record-sets \
            --hosted-zone-id "${HOSTED_ZONE_ID}" \
            --change-batch "${CHANGE_BATCH}" \
            --query 'ChangeInfo.Id' \
            --output text > /dev/null

          echo "âœ“ DNS ë ˆì½”ë“œ êµ¬ì„± ì™„ë£Œ (UPSERT)"

          # Job outputs ì„¤ì • (ë‹¤ìŒ jobìœ¼ë¡œ ì „ë‹¬)
          echo "service_name=${SERVICE_NAME}" >> $GITHUB_OUTPUT
          echo "cluster_name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "application_url=https://${DOMAIN}" >> $GITHUB_OUTPUT

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥ (ê°™ì€ job ë‚´ì—ì„œ ì‚¬ìš©)
          echo "APPLICATION_URL=https://${DOMAIN}" >> $GITHUB_ENV

  ## ë°°í¬ ëª¨ë‹ˆí„°ë§: ë°°í¬ëœ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
  monitor-deployment:
    needs: deploy-infrastructure-if-necessary
    runs-on: ubuntu-latest
    environment: ${{ inputs.deployment_phase }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: AWS ë¡œê·¸ì¸ ì •ë³´ ì •ì˜
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: ECS ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          SERVICE_NAME="${{ needs.deploy-infrastructure-if-necessary.outputs.service_name }}"
          CLUSTER_NAME="${{ needs.deploy-infrastructure-if-necessary.outputs.cluster_name }}"

          echo "=== ECS ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸ ==="
          echo "Cluster: ${CLUSTER_NAME}"
          echo "Service: ${SERVICE_NAME}"

          # ECS ì„œë¹„ìŠ¤ ì•ˆì •í™” ëŒ€ê¸°
          TIMEOUT=${{ inputs.ecs_stabilization_timeout }}
          MAX_ITERATIONS=$((TIMEOUT / 10))
          echo "ECS ì„œë¹„ìŠ¤ ì•ˆì •í™” ëŒ€ê¸° ì¤‘ (ìµœëŒ€ ${TIMEOUT}ì´ˆ)..."
          for i in $(seq 1 $MAX_ITERATIONS); do
            SERVICE_INFO=$(aws ecs describe-services \
              --cluster "${CLUSTER_NAME}" \
              --services "${SERVICE_NAME}" \
              --region ${REGION} \
              --output json)

            RUNNING_COUNT=$(echo "$SERVICE_INFO" | jq -r '.services[0].runningCount')
            DESIRED_COUNT=$(echo "$SERVICE_INFO" | jq -r '.services[0].desiredCount')
            DEPLOYMENT_COUNT=$(echo "$SERVICE_INFO" | jq -r '.services[0].deployments | length')

            # ë§¤ 5íšŒë§ˆë‹¤ ë¡œê·¸ ì¶œë ¥ (ë¡œê·¸ ê°„ì†Œí™”)
            if [ $((i % 5)) -eq 0 ] || [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ]; then
              echo "  [${i}/${MAX_ITERATIONS}] ì‹¤í–‰: ${RUNNING_COUNT}/${DESIRED_COUNT}, ë°°í¬: ${DEPLOYMENT_COUNT}"
            fi

            # ì•ˆì •í™” í™•ì¸
            if [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ] && [ "$DEPLOYMENT_COUNT" = "1" ]; then
              echo "âœ“ ECS ì„œë¹„ìŠ¤ ì•ˆì •í™” ì™„ë£Œ"
              break
            fi

            sleep 10
          done

          # ìµœì¢… ìƒíƒœ ì¶œë ¥
          echo ""
          aws ecs describe-services \
            --cluster "${CLUSTER_NAME}" \
            --services "${SERVICE_NAME}" \
            --region ${REGION} \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output table

      - name: ì• í”Œë¦¬ì¼€ì´ì…˜ Health Check
        continue-on-error: true
        id: health-check
        run: |
          set -euo pipefail
          APPLICATION_URL="${{ needs.deploy-infrastructure-if-necessary.outputs.application_url }}"
          HEALTH_CHECK_PATH="${{ inputs.health_check_path }}"

          echo "=== ì• í”Œë¦¬ì¼€ì´ì…˜ Health Check ==="
          echo "URL: ${APPLICATION_URL}${HEALTH_CHECK_PATH}"

          # ì• í”Œë¦¬ì¼€ì´ì…˜ ì‘ë‹µ ëŒ€ê¸° (ìµœëŒ€ 5ë¶„)
          echo "ì• í”Œë¦¬ì¼€ì´ì…˜ ì‘ë‹µ ëŒ€ê¸° ì¤‘..."
          APP_READY=false

          for i in {1..30}; do
            HTTP_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" "${APPLICATION_URL}${HEALTH_CHECK_PATH}" 2>/dev/null || echo "000")

            # ë§¤ 3íšŒë§ˆë‹¤ ë¡œê·¸ ì¶œë ¥ (ë¡œê·¸ ê°„ì†Œí™”)
            if [ $((i % 3)) -eq 0 ] || [ "$HTTP_CODE" = "200" ]; then
              echo "  [${i}/30] HTTP ${HTTP_CODE}"
            fi

            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ“ ì• í”Œë¦¬ì¼€ì´ì…˜ ì •ìƒ ì‘ë‹µ"
              APP_READY=true
              break
            fi

            sleep 10
          done

          if [ "$APP_READY" = false ]; then
            # GitHub Actions ê²½ê³  ì–´ë…¸í…Œì´ì…˜
            echo "::warning title=Health Check ì‹¤íŒ¨::ì• í”Œë¦¬ì¼€ì´ì…˜ ì‘ë‹µ ì—†ìŒ. URL: ${APPLICATION_URL}${HEALTH_CHECK_PATH}"

            # Job Summaryì— ìƒì„¸ ì •ë³´ ì¶”ê°€
            echo "## âš ï¸ Health Check ê²½ê³ " >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**ìƒíƒœ**: ì• í”Œë¦¬ì¼€ì´ì…˜ ì‘ë‹µ ì—†ìŒ" >> $GITHUB_STEP_SUMMARY
            echo "**URL**: [${APPLICATION_URL}${HEALTH_CHECK_PATH}](${APPLICATION_URL}${HEALTH_CHECK_PATH})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ğŸ” ê°€ëŠ¥í•œ ì›ì¸:" >> $GITHUB_STEP_SUMMARY
            echo "- ACM ì¸ì¦ì„œ ê²€ì¦ ëŒ€ê¸° ì¤‘ (5-30ë¶„ ì†Œìš”)" >> $GITHUB_STEP_SUMMARY
            echo "- ì»¨í…Œì´ë„ˆ ë‚´ë¶€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜¤ë¥˜" >> $GITHUB_STEP_SUMMARY
            echo "- DNS ì „íŒŒ ì§€ì—°" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ğŸ“‹ ë‹¤ìŒ ë‹¨ê³„:" >> $GITHUB_STEP_SUMMARY
            echo "1. **5-10ë¶„ ëŒ€ê¸°** í›„ URL ì§ì ‘ í™•ì¸" >> $GITHUB_STEP_SUMMARY
            echo "2. **CloudWatch Logs** í™•ì¸ (ECS Task ë¡œê·¸)" >> $GITHUB_STEP_SUMMARY
            echo "3. **ECS Task ìƒíƒœ** í™•ì¸ (ì¬ì‹œì‘ ë°˜ë³µ ì—¬ë¶€)" >> $GITHUB_STEP_SUMMARY

            echo ""
            echo "âš ï¸  ê²½ê³ : Health check ì‘ë‹µ ì—†ìŒ"
            echo "   - DNS ì „íŒŒ ì§€ì—°ì´ë‚˜ ACM ì¸ì¦ì„œ ê²€ì¦ ëŒ€ê¸° ì¤‘ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤"
            echo "   - ì§ì ‘ í™•ì¸: ${APPLICATION_URL}${HEALTH_CHECK_PATH}"
            echo ""
            echo "ğŸ’¡ ì¼ë°˜ì ìœ¼ë¡œ ACM ì¸ì¦ì„œ ê²€ì¦ì€ 5-30ë¶„ ì†Œìš”ë©ë‹ˆë‹¤"
            exit 1
          fi

          # Health Check ì‘ë‹µ ì¶œë ¥
          echo ""
          echo "Health Check ì‘ë‹µ:"
          curl -k -s "${APPLICATION_URL}${HEALTH_CHECK_PATH}" | jq . 2>/dev/null || curl -k -s "${APPLICATION_URL}${HEALTH_CHECK_PATH}"

      - name: ë°°í¬ ì™„ë£Œ ì•Œë¦¼
        if: always()
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          IMAGE_TAG="${{ needs.build-docker-image.outputs.image_tag }}"
          APPLICATION_URL="${{ needs.deploy-infrastructure-if-necessary.outputs.application_url }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"
          HEALTH_CHECK_STATUS="${{ steps.health-check.outcome }}"

          echo ""
          echo "=========================================="
          echo "âœ… ë°°í¬ ì™„ë£Œ"
          echo "=========================================="
          echo ""
          echo "ì• í”Œë¦¬ì¼€ì´ì…˜: ${IMAGE_NAME}"
          echo "ë²„ì „: ${IMAGE_TAG}"
          echo "ë°°í¬ ë‹¨ê³„: ${DEPLOYMENT_PHASE}"
          echo "ì ‘ì† URL: ${APPLICATION_URL}"
          echo ""

          # Health Check ê²°ê³¼ í‘œì‹œ
          if [ "$HEALTH_CHECK_STATUS" = "failure" ]; then
            echo "âš ï¸  Health Check: ì‘ë‹µ ì—†ìŒ"
            echo "   â†’ ${APPLICATION_URL}/api/health í™•ì¸ í•„ìš”"
            echo "   â†’ ACM ì¸ì¦ì„œ ê²€ì¦ ëŒ€ê¸° ì¤‘ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤ (5-30ë¶„)"
            echo "   â†’ CloudWatch Logsì—ì„œ ì»¨í…Œì´ë„ˆ ë¡œê·¸ í™•ì¸ ê¶Œì¥"
          elif [ "$HEALTH_CHECK_STATUS" = "success" ]; then
            echo "âœ… Health Check: ì •ìƒ"
          fi

          echo ""
          echo "=========================================="
