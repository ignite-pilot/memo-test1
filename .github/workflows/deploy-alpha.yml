name: Alpha ë°°í¬

on:
  workflow_dispatch:
    inputs:
      deployment_phase:
        description: 'ì•± ë°°í¬ ë‹¨ê³„ (ê¸°ë³¸ê°’: alpha). alpha, beta, production ì¤‘ ì„ íƒ. ì´ì™¸ì˜ ê°’ì€ í—ˆìš©ë˜ì§€ ì•ŠìŒ.'
        required: false
        type: string
        default: 'alpha'
      image_name:
        description: 'Docker ì´ë¯¸ì§€ ì´ë¦„ (ê¸°ë³¸ê°’: repository ì´ë¦„)'
        required: false
        type: string
      container_port:
        description: 'ì»¨í…Œì´ë„ˆ í¬íŠ¸ ë²ˆí˜¸ (ê¸°ë³¸ê°’: 8501)'
        required: false
        type: string
        default: '8501'
      health_check_path:
        description: 'Health check endpoint ê²½ë¡œ (ê¸°ë³¸ê°’: /api/health)'
        required: false
        type: string
        default: '/api/health'
      ecr_base_name:
        description: 'ECR ê¸°ë³¸ ê²½ë¡œ (ê¸°ë³¸ê°’: aws-deploy-wizard)'
        required: false
        type: string
        default: 'aws-deploy-wizard'
      ecs_cluster_base_name:
        description: 'ECS Cluster ì´ë¦„ (ê¸°ë³¸ê°’: aws-deploy-wizard)'
        required: false
        type: string
        default: 'aws-deploy-wizard'
      secrets_manager_passwords_set_name:
        description: 'Secrets Manager ë³´ì•ˆ ì•”í˜¸ ì´ë¦„ (ê¸°ë³¸ê°’: prod/ignite-pilot/postgresInfo2)'
        required: false
        type: string
        default: 'prod/ignite-pilot/postgresInfo2'
      task_cpu:
        description: 'ECS Task CPU ì„¤ì • (ê¸°ë³¸ê°’: 512 = 0.5 vCPU)'
        required: false
        type: string
        default: '512'
      task_memory:
        description: 'ECS Task Memory ì„¤ì • (ê¸°ë³¸ê°’: 1024 MB)'
        required: false
        type: string
        default: '1024'

jobs:
  ## Docker image ë¹Œë“œ: ì• í”Œë¦¬ì¼€ì´ì…˜ì„ íŒ¨í‚¤ì§•í•©ë‹ˆë‹¤.
  build-docker-image:
    runs-on: ubuntu-latest
    environment: alpha
    permissions:
      id-token: write
      contents: read
    outputs:
      image_name: ${{ steps.set-image-name.outputs.image_name }}
      image_tag: ${{ steps.set-image-name.outputs.image_tag }}

    steps:
      - name: ì½”ë“œ ì²´í¬ì•„ì›ƒ
        uses: actions/checkout@v4

      - name: ì• í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬ ë‹¨ê³„ ê²€ì¦
        run: |
          if [ ${{ inputs.deployment_phase }} != "alpha" ] && [ ${{ inputs.deployment_phase }} != "beta" ] && [ ${{ inputs.deployment_phase }} != "production" ]; then
            echo "âŒ ì˜¤ë¥˜: ì˜ëª»ëœ deployment_phase ê°’ì…ë‹ˆë‹¤. í—ˆìš©ë˜ëŠ” ê°’ì€ 'alpha', 'beta', 'production' ì…ë‹ˆë‹¤."
            exit 1
          fi

      - name: ì´ë¯¸ì§€ ì´ë¦„ ë° íƒœê·¸ ì„¤ì •
        id: set-image-name
        run: |
          # Inputìœ¼ë¡œ ì´ë¯¸ì§€ ì´ë¦„ì´ ì œê³µë˜ì—ˆìœ¼ë©´ ì‚¬ìš©, ì•„ë‹ˆë©´ repository ì´ë¦„ ì‚¬ìš©
          if [ -n "${{ inputs.image_name }}" ]; then
            IMAGE_NAME="${{ inputs.image_name }}"
          else
            IMAGE_NAME="${{ github.event.repository.name }}"
          fi

          # íƒœê·¸ëŠ” git commit SHAì˜ ì§§ì€ ë²„ì „ ì‚¬ìš©
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_TAG_SHORT="${IMAGE_TAG:0:7}"

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG_SHORT}" >> $GITHUB_OUTPUT

          echo "ğŸ“¦ Docker ì´ë¯¸ì§€ ì´ë¦„: ${IMAGE_NAME}"
          echo "ğŸ·ï¸  Docker ì´ë¯¸ì§€ íƒœê·¸: ${IMAGE_TAG_SHORT}"

      - name: Docker image ìƒì„±(ì• í”Œë¦¬ì¼€ì´ì…˜ íŒ¨í‚¤ì§•)   # Target ë°°í¬í™˜ê²½ì— ë”°ë¼ ì•„í‚¤í…ì³ ëª…ì‹œ í•„ìš”í•  ìˆ˜ë„ ìˆìŒ
        run: |
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          IMAGE_TAG="${{ steps.set-image-name.outputs.image_tag }}"

          echo "ğŸ”¨ Docker ì´ë¯¸ì§€ ë¹Œë“œ ì‹œì‘..."
          echo "ì´ë¯¸ì§€: ${IMAGE_NAME}:${IMAGE_TAG}"

          # Docker ì´ë¯¸ì§€ ë¹Œë“œ (ë£¨íŠ¸ ë””ë ‰í† ë¦¬ì˜ Dockerfile ì‚¬ìš©)
          docker build \
            --tag "${IMAGE_NAME}:${IMAGE_TAG}" \
            --tag "${IMAGE_NAME}:latest" \
            --file Dockerfile \
            .

          echo "âœ… Docker ì´ë¯¸ì§€ ë¹Œë“œ ì™„ë£Œ"

      - name: ìƒì„±í•œ Docker image ê²€ì¦
        run: |
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          IMAGE_TAG="${{ steps.set-image-name.outputs.image_tag }}"

          echo "ğŸ” Docker ì´ë¯¸ì§€ ê²€ì¦ ì¤‘..."

          # ì´ë¯¸ì§€ ì¡´ì¬ í™•ì¸
          if ! docker images "${IMAGE_NAME}:${IMAGE_TAG}" --format "{{.Repository}}:{{.Tag}}" | grep -q "${IMAGE_NAME}:${IMAGE_TAG}"; then
            echo "âŒ ì˜¤ë¥˜: Docker ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (${IMAGE_NAME}:${IMAGE_TAG})"
            echo ""
            echo "ì‚¬ìš© ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ëª©ë¡:"
            docker images "${IMAGE_NAME}" --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}" || true
            exit 1
          fi

          echo "âœ“ ì´ë¯¸ì§€ ì¡´ì¬ í™•ì¸ ì™„ë£Œ"

          # ì´ë¯¸ì§€ ìƒì„¸ ì •ë³´ í™•ì¸
          echo ""
          echo "=== Docker ì´ë¯¸ì§€ ì •ë³´ ==="
          docker images "${IMAGE_NAME}" --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"

          echo ""
          echo "=== ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„° ==="
          docker inspect "${IMAGE_NAME}:${IMAGE_TAG}" --format='
          - ìƒì„± ì‹œê°„: {{.Created}}
          - ì•„í‚¤í…ì²˜: {{.Architecture}}
          - OS: {{.Os}}
          - í¬ê¸°: {{.Size}} bytes
          - Exposed Ports: {{.Config.ExposedPorts}}
          - Entrypoint: {{.Config.Entrypoint}}
          - Cmd: {{.Config.Cmd}}'

          echo ""
          echo "âœ… Docker ì´ë¯¸ì§€ ê²€ì¦ ì™„ë£Œ"

  ## AWS Infrastructure ë°°í¬: í•„ìš”í•œ ì¸í”„ë¼ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ì¤‘ë³µ ë°°í¬ëœ ì¸í”„ë¼ê°€ ìˆë‹¤ë©´, ê±´ë„ˆëœë‹ˆë‹¤.
  deploy-infrastructure-if-necessary:
    needs: build-docker-image
    runs-on: ubuntu-latest
    environment: alpha
    permissions:
      id-token: write
      contents: read

    steps:
      - name: ì½”ë“œ ì²´í¬ì•„ì›ƒ
        uses: actions/checkout@v4

      - name: AWS ë¡œê·¸ì¸ ì •ë³´ ì •ì˜
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      # ë„ë©”ì¸ ì ‘ê·¼ ì¸ì¦ì„œ ìƒì„±ì„ ìœ„í•œ ì‚¬ì „ ì‘ì—…
      # ë„ë©”ì¸ ìƒì„±ì€ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ë¯€ë¡œ, ìµœëŒ€í•œ ë¹¨ë¦¬ ì§„í–‰í•˜ê³  ìµœì¢… ê²€ì¦ ë‹¨ê³„ì—ì„œ í™•ì¸í•´ ë¹Œë“œ ì‹œê°„ì„ ì¤„ì…ë‹ˆë‹¤.
      - name: Route53 Hosted Zone í™•ì¸
        run: |
          ROOT_DOMAIN="ig-pilot.com"

          echo "=== Route53 Hosted Zone í™•ì¸ ==="
          echo "ë„ë©”ì¸: ${ROOT_DOMAIN}"
          echo ""

          # Hosted Zone ì¡´ì¬ í™•ì¸
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones \
            --query "HostedZones[?Name=='${ROOT_DOMAIN}.'].Id" \
            --output text 2>/dev/null | cut -d'/' -f3)

          if [ -n "$HOSTED_ZONE_ID" ]; then
            echo "âœ“ ê¸°ì¡´ Hosted Zone ì‚¬ìš©: ${HOSTED_ZONE_ID}"
          else
            echo "Hosted Zone ìƒì„± ì¤‘: ${ROOT_DOMAIN}"

            # Caller Reference (ê³ ìœ  ì‹ë³„ì)
            CALLER_REF="github-actions-$(date +%s)"

            HOSTED_ZONE_ID=$(aws route53 create-hosted-zone \
              --name "${ROOT_DOMAIN}" \
              --caller-reference "${CALLER_REF}" \
              --hosted-zone-config Comment="Created by GitHub Actions" \
              --query 'HostedZone.Id' \
              --output text | cut -d'/' -f3)

            echo "âœ“ Hosted Zone ìƒì„± ì™„ë£Œ: ${HOSTED_ZONE_ID}"
          fi

          echo ""
          echo "HOSTED_ZONE_ID=${HOSTED_ZONE_ID}" >> $GITHUB_ENV

      # HTTPSë¥¼ ìœ„í•œ SSL/TLS ì¸ì¦ì„œ ìƒì„±
      - name: Amazon Certificate Manager ìš© ì¸ì¦ì„œ ìƒì„±
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"
          ROOT_DOMAIN="ig-pilot.com"

          echo "=== ACM ì¸ì¦ì„œ í™•ì¸ ==="

          # ë„ë©”ì¸ ì„¤ì •
          if [ "$DEPLOYMENT_PHASE" = "production" ]; then
            WILDCARD_DOMAIN="*.${IMAGE_NAME}.${ROOT_DOMAIN}"
            DOMAIN="${IMAGE_NAME}.${ROOT_DOMAIN}"
          else
            WILDCARD_DOMAIN="*.${DEPLOYMENT_PHASE}.${IMAGE_NAME}.${ROOT_DOMAIN}"
            DOMAIN="${DEPLOYMENT_PHASE}.${IMAGE_NAME}.${ROOT_DOMAIN}"
          fi

          echo "ì™€ì¼ë“œì¹´ë“œ ë„ë©”ì¸: ${WILDCARD_DOMAIN}"
          echo "ë£¨íŠ¸ ë„ë©”ì¸: ${DOMAIN}"
          echo ""

          # ê¸°ì¡´ ì¸ì¦ì„œ ê²€ìƒ‰ (ISSUED ë˜ëŠ” PENDING_VALIDATION ìƒíƒœ)
          CERTIFICATE_ARN=""
          CERT_LIST=$(aws acm list-certificates \
            --certificate-statuses ISSUED PENDING_VALIDATION \
            --region ap-northeast-2 \
            --query 'CertificateSummaryList[*].CertificateArn' \
            --output text)

          for CERT_ARN in $CERT_LIST; do
            # ì¸ì¦ì„œ ìƒì„¸ ì •ë³´ ì¡°íšŒ
            CERT_DETAIL=$(aws acm describe-certificate \
              --certificate-arn "$CERT_ARN" \
              --region ap-northeast-2 \
              --output json)

            CERT_DOMAIN=$(echo "$CERT_DETAIL" | jq -r '.Certificate.DomainName')
            SAN_LIST=$(echo "$CERT_DETAIL" | jq -r '.Certificate.SubjectAlternativeNames[]')
            CERT_STATUS=$(echo "$CERT_DETAIL" | jq -r '.Certificate.Status')

            # ë„ë©”ì¸ ì¼ì¹˜ í™•ì¸
            if [ "$CERT_DOMAIN" = "$WILDCARD_DOMAIN" ] && echo "$SAN_LIST" | grep -q "$DOMAIN"; then
              echo "âœ“ ê¸°ì¡´ ì¸ì¦ì„œ ë°œê²¬: $CERT_ARN"
              echo "  ìƒíƒœ: $CERT_STATUS"
              CERTIFICATE_ARN="$CERT_ARN"
              break
            fi
          done

          # ì¸ì¦ì„œê°€ ì—†ìœ¼ë©´ ìƒì„±
          if [ -z "$CERTIFICATE_ARN" ]; then
            echo "ê¸°ì¡´ ì¸ì¦ì„œ ì—†ìŒ - ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤..."

            # ACM ì¸ì¦ì„œ ìš”ì²­
            echo "ACM ì¸ì¦ì„œ ìš”ì²­ ì¤‘..."
            CERTIFICATE_ARN=$(aws acm request-certificate \
              --domain-name "${WILDCARD_DOMAIN}" \
              --subject-alternative-names "${DOMAIN}" \
              --validation-method DNS \
              --region ap-northeast-2 \
              --query 'CertificateArn' \
              --output text)

            echo "âœ“ ì¸ì¦ì„œ ìš”ì²­ ì™„ë£Œ: ${CERTIFICATE_ARN}"
          fi

          echo ""
          echo "CERTIFICATE_ARN=${CERTIFICATE_ARN}" >> $GITHUB_ENV
          echo "âœ“ ì¸ì¦ì„œ ARN: ${CERTIFICATE_ARN}"

      - name: ACM DNS ê²€ì¦ ë ˆì½”ë“œë¥¼ Route53ì— ì¶”ê°€
        run: |
          CERTIFICATE_ARN="${{ env.CERTIFICATE_ARN }}"
          HOSTED_ZONE_ID="${{ env.HOSTED_ZONE_ID }}"

          echo "=== ACM DNS ê²€ì¦ ë ˆì½”ë“œ ìƒì„± ==="
          echo "ì¸ì¦ì„œ ARN: ${CERTIFICATE_ARN}"
          echo "Hosted Zone ID: ${HOSTED_ZONE_ID}"
          echo ""

          # ì¸ì¦ì„œ ìƒíƒœ í™•ì¸
          CERT_STATUS=$(aws acm describe-certificate \
            --certificate-arn "${CERTIFICATE_ARN}" \
            --region ap-northeast-2 \
            --query 'Certificate.Status' \
            --output text)

          echo "ì¸ì¦ì„œ ìƒíƒœ: ${CERT_STATUS}"

          # ISSUED ìƒíƒœë©´ ì´ë¯¸ ê²€ì¦ ì™„ë£Œ
          if [ "$CERT_STATUS" = "ISSUED" ]; then
            echo "âœ“ ì¸ì¦ì„œê°€ ì´ë¯¸ ë°œê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤ (DNS ë ˆì½”ë“œ ì¶”ê°€ ë¶ˆí•„ìš”)"
            exit 0
          fi

          # DNS ê²€ì¦ ë ˆì½”ë“œê°€ ìƒì„±ë  ë•Œê¹Œì§€ ëŒ€ê¸° (ìµœëŒ€ 60ì´ˆ)
          echo ""
          echo "DNS ê²€ì¦ ë ˆì½”ë“œ ëŒ€ê¸° ì¤‘..."
          for i in {1..12}; do
            sleep 5
            VALIDATION_RECORDS=$(aws acm describe-certificate \
              --certificate-arn "${CERTIFICATE_ARN}" \
              --region ap-northeast-2 \
              --query 'Certificate.DomainValidationOptions[0].ResourceRecord' \
              --output json)

            if [ "$VALIDATION_RECORDS" != "null" ]; then
              echo "âœ“ ê²€ì¦ ë ˆì½”ë“œ ë°œê²¬ (${i}íšŒ ì‹œë„)"
              break
            fi
            echo "  ëŒ€ê¸° ì¤‘... (${i}íšŒ ì‹œë„)"
          done

          if [ "$VALIDATION_RECORDS" = "null" ]; then
            echo "âœ— ê²€ì¦ ë ˆì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
            exit 1
          fi

          # DNS ê²€ì¦ ë ˆì½”ë“œë¥¼ Route53ì— ì¶”ê°€
          echo ""
          echo "Route53ì— DNS ê²€ì¦ ë ˆì½”ë“œ ì¶”ê°€ ì¤‘..."

          VALIDATION_OPTIONS=$(aws acm describe-certificate \
            --certificate-arn "${CERTIFICATE_ARN}" \
            --region ap-northeast-2 \
            --query 'Certificate.DomainValidationOptions' \
            --output json)

          echo "$VALIDATION_OPTIONS" | jq -c '.[]' | while read -r option; do
            RECORD_NAME=$(echo "$option" | jq -r '.ResourceRecord.Name')
            RECORD_VALUE=$(echo "$option" | jq -r '.ResourceRecord.Value')
            RECORD_TYPE=$(echo "$option" | jq -r '.ResourceRecord.Type')

            if [ "$RECORD_NAME" != "null" ]; then
              echo "  DNS ë ˆì½”ë“œ ì¶”ê°€: ${RECORD_NAME} (${RECORD_TYPE})"

              aws route53 change-resource-record-sets \
                --hosted-zone-id "${HOSTED_ZONE_ID}" \
                --change-batch "{
                  \"Changes\": [{
                    \"Action\": \"UPSERT\",
                    \"ResourceRecordSet\": {
                      \"Name\": \"${RECORD_NAME}\",
                      \"Type\": \"${RECORD_TYPE}\",
                      \"TTL\": 300,
                      \"ResourceRecords\": [{\"Value\": \"${RECORD_VALUE}\"}]
                    }
                  }]
                }" > /dev/null

              echo "  âœ“ DNS ë ˆì½”ë“œ ì¶”ê°€ ì™„ë£Œ"
            fi
          done

          echo ""
          echo "âœ“ DNS ê²€ì¦ ë ˆì½”ë“œ ì¶”ê°€ ì™„ë£Œ"
          echo "ğŸ’¡ ACM ì¸ì¦ì„œëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ê²€ì¦ë©ë‹ˆë‹¤ (5-30ë¶„ ì†Œìš”)"

      - name: ECR ìƒì„±
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          REPOSITORY_NAME="${{ inputs.ecr_base_name }}/${IMAGE_NAME}"

          echo "=== Elastic Container Repository í™•ì¸ ==="
          echo "Repository ì´ë¦„: ${REPOSITORY_NAME}"
          echo ""

          # ë¦¬í¬ì§€í† ë¦¬ ì¡´ì¬ í™•ì¸
          if aws ecr describe-repositories --repository-names "${REPOSITORY_NAME}" --region ap-northeast-2 >/dev/null 2>&1; then
            echo "âœ“ ê¸°ì¡´ ECR ì‚¬ìš©: ${REPOSITORY_NAME}"
            REPOSITORY_URI=$(aws ecr describe-repositories --repository-names "${REPOSITORY_NAME}" --region ap-northeast-2 --query 'repositories[0].repositoryUri' --output text)
            echo "  URI: ${REPOSITORY_URI}"
          else
            # ë¦¬í¬ì§€í† ë¦¬ ìƒì„±
            echo "ECR ìƒì„± ì¤‘: ${REPOSITORY_NAME}"
            REPOSITORY_URI=$(aws ecr create-repository \
              --repository-name "${REPOSITORY_NAME}" \
              --region ap-northeast-2 \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE \
              --query 'repository.repositoryUri' \
              --output text)
            echo "âœ“ ECR ìƒì„± ì™„ë£Œ: ${REPOSITORY_URI}"
          fi

          echo ""
          echo "REPOSITORY_URI=${REPOSITORY_URI}" >> $GITHUB_ENV

      - name: ë¹Œë“œí•œ Docker ì´ë¯¸ì§€ í‘¸ì‹œ
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          IMAGE_TAG="${{ needs.build-docker-image.outputs.image_tag }}"
          REPOSITORY_URI="${{ env.REPOSITORY_URI }}"

          echo "=== Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ ==="
          echo "ECR URI: ${REPOSITORY_URI}"
          echo "ì´ë¯¸ì§€ íƒœê·¸: ${IMAGE_TAG}, latest"
          echo ""

          # ECR ë¡œê·¸ì¸
          echo "ECR ì¸ì¦ ì¤‘..."
          aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin ${REPOSITORY_URI%%/*}

          # Docker ì´ë¯¸ì§€ ë¹Œë“œ (linux/amd64 í”Œë«í¼ - ECS Fargate ìš”êµ¬ì‚¬í•­)
          echo "Docker ì´ë¯¸ì§€ ë¹Œë“œ ì¤‘ (linux/amd64)..."
          docker build --platform linux/amd64 \
            -t ${REPOSITORY_URI}:${IMAGE_TAG} \
            -t ${REPOSITORY_URI}:latest \
            -f Dockerfile \
            .

          # ECRì— í‘¸ì‹œ
          echo ""
          echo "ECRì— í‘¸ì‹œ ì¤‘..."
          docker push ${REPOSITORY_URI}:${IMAGE_TAG}
          docker push ${REPOSITORY_URI}:latest

          echo ""
          echo "âœ“ Docker ì´ë¯¸ì§€ í‘¸ì‹œ ì™„ë£Œ"
          echo "  - ${REPOSITORY_URI}:${IMAGE_TAG}"
          echo "  - ${REPOSITORY_URI}:latest"

      - name: ECS Cluster ìƒì„±
        run: |
          CLUSTER_NAME="${{ inputs.ecs_cluster_base_name }}"

          echo "=== ECS Cluster í™•ì¸ ==="
          echo "Cluster ì´ë¦„: ${CLUSTER_NAME}"
          echo ""

          # Cluster ì¡´ì¬ í™•ì¸
          CLUSTER_STATUS=$(aws ecs describe-clusters \
            --clusters "${CLUSTER_NAME}" \
            --region ap-northeast-2 \
            --query 'clusters[0].status' \
            --output text 2>/dev/null || echo "NONE")

          if [ "$CLUSTER_STATUS" = "ACTIVE" ]; then
            echo "âœ“ ê¸°ì¡´ ECS Cluster ì‚¬ìš©: ${CLUSTER_NAME}"
          elif [ "$CLUSTER_STATUS" = "NONE" ] || [ "$CLUSTER_STATUS" = "INACTIVE" ]; then
            # Cluster ìƒì„±
            echo "ECS Cluster ìƒì„± ì¤‘: ${CLUSTER_NAME}"
            aws ecs create-cluster \
              --cluster-name "${CLUSTER_NAME}" \
              --region ap-northeast-2 \
              --tags key=Name,value=${CLUSTER_NAME} key=ManagedBy,value=github-actions \
              > /dev/null

            echo "âœ“ ECS Cluster ìƒì„± ì™„ë£Œ: ${CLUSTER_NAME}"
          else
            echo "âš ï¸  Cluster ìƒíƒœ í™•ì¸ ë¶ˆê°€: ${CLUSTER_STATUS}"
          fi

          echo ""
          echo "CLUSTER_NAME=${CLUSTER_NAME}" >> $GITHUB_ENV

      # ECS Task ì‹¤í–‰ì„ ìœ„í•œ IAM ì—­í•  í™•ì¸
      - name: IAM Execution Role ìƒì„± ë° í™•ì¸
        run: |
          set -euo pipefail
          
          ROLE_NAME="ecsTaskExecutionRole"
          REGION="ap-northeast-2"
          
          echo "=== IAM Execution Role í™•ì¸ ==="
          echo "Role ì´ë¦„: ${ROLE_NAME}"
          echo ""
          
          TRUST_POLICY='{
            "Version": "2012-10-17",
            "Statement": [{
              "Effect": "Allow",
              "Principal": { "Service": "ecs-tasks.amazonaws.com" },
              "Action": "sts:AssumeRole"
            }]
          }'
          
          SECRETS_POLICY='{
            "Version": "2012-10-17",
            "Statement": [{
              "Effect": "Allow",
              "Action": "secretsmanager:GetSecretValue",
              "Resource": "arn:aws:secretsmanager:'"${REGION}"':*:secret:prod/ignite-pilot/*"
            }]
          }'
          
          # Role ì¡´ì¬ ì—¬ë¶€ í™•ì¸
          if aws iam get-role --role-name "${ROLE_NAME}" >/dev/null 2>&1; then
            echo "âœ“ ê¸°ì¡´ Execution Role ì‚¬ìš©: ${ROLE_NAME}"
          else
            echo "Execution Role ìƒì„± ì¤‘: ${ROLE_NAME}"
          
            aws iam create-role \
              --role-name "${ROLE_NAME}" \
              --assume-role-policy-document "${TRUST_POLICY}" \
              >/dev/null
          
            echo "âœ“ Role ìƒì„± ì™„ë£Œ"
          fi
          
          # Role ARN ì¡°íšŒ (ê³µí†µ)
          ROLE_ARN=$(aws iam get-role \
            --role-name "${ROLE_NAME}" \
            --query 'Role.Arn' \
            --output text)
          
          echo "âœ“ Execution Role ARN: ${ROLE_ARN}"
          
          # AWS ê´€ë¦¬í˜• ì •ì±… ì—°ê²° (ì¤‘ë³µ ì—°ê²° ì•ˆì „)
          aws iam attach-role-policy \
            --role-name "${ROLE_NAME}" \
            --policy-arn "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
          
          echo "âœ“ AmazonECSTaskExecutionRolePolicy ì—°ê²° ì™„ë£Œ"
          
          # Secrets Manager inline policy (í•­ìƒ ë³´ì¥)
          aws iam put-role-policy \
            --role-name "${ROLE_NAME}" \
            --policy-name "SecretsManagerAccess" \
            --policy-document "${SECRETS_POLICY}"
          
          echo "âœ“ Secrets Manager ì ‘ê·¼ ê¶Œí•œ ë³´ì¥ ì™„ë£Œ"
          
          echo ""
          echo "EXECUTION_ROLE_ARN=${ROLE_ARN}" >> "$GITHUB_ENV"

      # ECS Task ë¡œê·¸ ê¸°ë¡ ë° í™•ì¸ì„ ìœ„í•œ Log Group
      # Service (ì• í”Œë¦¬ì¼€ì´ì…˜) ë‹¨ìœ„ë¡œ Log Group ìƒì„± (AWS Best Practice)
      - name: CloudWatch Log Group í™•ì¸
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          CLUSTER_NAME="${{ inputs.ecs_cluster_base_name }}"
          LOG_GROUP="/ecs/${CLUSTER_NAME}/${IMAGE_NAME}"

          echo "=== CloudWatch Log Group í™•ì¸ ==="
          echo "Log Group: ${LOG_GROUP}"
          echo ""

          # Log Group ì¡´ì¬ í™•ì¸
          if aws logs describe-log-groups --log-group-name-prefix "${LOG_GROUP}" --region ap-northeast-2 | grep -q "${LOG_GROUP}"; then
            echo "âœ“ ê¸°ì¡´ Log Group ì‚¬ìš©: ${LOG_GROUP}"
          else
            echo "Log Group ìƒì„± ì¤‘: ${LOG_GROUP}"

            aws logs create-log-group \
              --log-group-name "${LOG_GROUP}" \
              --region ap-northeast-2

            echo "âœ“ Log Group ìƒì„± ì™„ë£Œ: ${LOG_GROUP}"
          fi

          echo ""
          echo "LOG_GROUP=${LOG_GROUP}" >> $GITHUB_ENV

      # ECS Task Definition ê´€ë¦¬ì‹œ ì£¼ì˜ ì‚¬í•­:
      #  1. ë§Œì•½ ì½˜ì†”ì—ì„œ ì†ìœ¼ë¡œ ì§ì ‘ Revision ì˜¬ë¦´ ê²½ìš°, workflow ë¥¼ ì ì ˆí•˜ê²Œ ìˆ˜ì •í•˜ì§€ ì•Šìœ¼ë©´ ë°°í¬ê°€ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ!!
      #  2. Task definition versioning policy:
      #     a. alpha, beta ì—ì„œëŠ” revision ìœ ì§€. ì™œëƒë©´ image tag ê°€ latest ì´ê¸° ë•Œë¬¸.
      #     b. production ì—ì„œëŠ” revision í•­ìƒ ì¦ê°€. ì™œëƒë©´ image tag ë¥¼ ë§¤ë²ˆ ë³€ê²½í•˜ê¸° ë•Œë¬¸.
      - name: ECS Task Definition í™•ì¸ ë° ë“±ë¡
        run: |
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          IMAGE_TAG="${{ needs.build-docker-image.outputs.image_tag }}"
          REPOSITORY_URI="${{ env.REPOSITORY_URI }}"
          EXECUTION_ROLE_ARN="${{ env.EXECUTION_ROLE_ARN }}"
          LOG_GROUP="${{ env.LOG_GROUP }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"

          FAMILY="${IMAGE_NAME}-task"
          # Alpha/Beta í™˜ê²½ì€ latest íƒœê·¸ ì‚¬ìš© (IMAGE_TAG ë¬´ì‹œ)
          IMAGE_URI="${REPOSITORY_URI}:latest"
          CONTAINER_PORT=${{ inputs.container_port }}
          SECRET_NAME="${{ inputs.secrets_manager_passwords_set_name }}"

          echo "=== ECS Task Definition í™•ì¸ ==="
          echo "Family: ${FAMILY}"
          echo "Image: ${IMAGE_URI}"
          echo "Port: ${CONTAINER_PORT}"
          echo ""

          # Task Definition Family ì¡´ì¬ ì—¬ë¶€ í™•ì¸
          EXISTING_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "${FAMILY}" \
            --region ap-northeast-2 \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text 2>/dev/null || echo "")

          if [ -n "$EXISTING_TASK_DEF" ]; then
            # ê¸°ì¡´ Task Definitionì´ ìˆìœ¼ë©´ ìµœì‹  revision ì¬ì‚¬ìš©
            TASK_DEF_ARN="$EXISTING_TASK_DEF"
            REVISION=$(echo "${TASK_DEF_ARN}" | awk -F: '{print $NF}')
            echo "âœ“ ê¸°ì¡´ Task Definition ì¬ì‚¬ìš©: ${FAMILY}:${REVISION}"
            echo "  (Alpha/Beta í™˜ê²½ì€ latest íƒœê·¸ë¡œ force deployment ì‚¬ìš©)"
          else
            # Task Definitionì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
            echo "Task Definitionì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤..."
            echo ""

            # Secrets Managerì—ì„œ í‚¤ ëª©ë¡ ë™ì  ì¡°íšŒ
            echo "Secrets Manager í‚¤ ì¡°íšŒ ì¤‘..."
            SECRET_JSON=$(aws secretsmanager get-secret-value \
              --secret-id "${SECRET_NAME}" \
              --region ap-northeast-2 \
              --query SecretString \
              --output text 2>/dev/null || echo "{}")

            # JSON í‚¤ ëª©ë¡ ì¶”ì¶œ ë° secrets í•„ë“œ ë™ì  ìƒì„± (jq í™œìš©)
            if [ "$SECRET_JSON" != "{}" ]; then
              echo "âœ“ Secret ë°œê²¬, ë™ì ìœ¼ë¡œ ë§¤í•‘ ìƒì„± ì¤‘..."

              # jqë¥¼ ì‚¬ìš©í•˜ì—¬ secrets í•„ë“œ ìƒì„± (ê°„ê²°í•˜ê³  ì•ˆì „)
              SECRETS_ARRAY=$(echo "$SECRET_JSON" | jq -c --arg sn "$SECRET_NAME" \
                '[keys[] | {name: ., valueFrom: ($sn + ":" + . + "::")}]')

              # ë§¤í•‘ëœ í‚¤ ê°œìˆ˜ ê³„ì‚°
              SECRET_COUNT=$(echo "$SECRETS_ARRAY" | jq 'length')
              echo "âœ“ Secrets í•„ë“œ ìƒì„± ì™„ë£Œ (${SECRET_COUNT}ê°œ í‚¤ ë§¤í•‘ë¨)"
            else
              echo "âš ï¸  Secretì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í™˜ê²½ë³€ìˆ˜ fallbackë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤."
              SECRETS_ARRAY="[]"
            fi

            # ë§¤í•‘ëœ í™˜ê²½ë³€ìˆ˜ í‚¤ ëª©ë¡ ì¶œë ¥. ë””ë²„ê¹… ëª©ì ìœ¼ë¡œ í™œìš©í•©ë‹ˆë‹¤.
            if [ "$SECRETS_ARRAY" != "[]" ]; then
              echo "ë§¤í•‘ëœ í™˜ê²½ë³€ìˆ˜ í‚¤:"
              echo "$SECRETS_ARRAY" | jq -r '.[].name' | sed 's/^/  - /'
            fi
            echo ""

            # Container Definitions ìƒì„± (jq í™œìš©ìœ¼ë¡œ ê°€ë…ì„± ë° ì•ˆì •ì„± í–¥ìƒ)
            CONTAINER_DEFS=$(jq -nc \
              --arg name "$IMAGE_NAME" \
              --arg image "$IMAGE_URI" \
              --argjson port "$CONTAINER_PORT" \
              --arg phase "$DEPLOYMENT_PHASE" \
              --arg log_group "$LOG_GROUP" \
              --argjson secrets "$SECRETS_ARRAY" \
              '[{
                name: $name,
                image: $image,
                portMappings: [{
                  containerPort: $port,
                  protocol: "tcp"
                }],
                environment: [
                  {name: "ENVIRONMENT", value: $phase},
                  {name: "PHASE", value: $phase}
                ],
                secrets: $secrets,
                logConfiguration: {
                  logDriver: "awslogs",
                  options: {
                    "awslogs-group": $log_group,
                    "awslogs-region": "ap-northeast-2",
                    "awslogs-stream-prefix": $name
                  }
                },
                essential: true
              }]')

            # Task Definition ë“±ë¡ (ìµœì´ˆ 1íšŒë§Œ)
            TASK_DEF_ARN=$(aws ecs register-task-definition \
              --family "${FAMILY}" \
              --network-mode awsvpc \
              --requires-compatibilities FARGATE \
              --cpu ${{ inputs.task_cpu }} \
              --memory ${{ inputs.task_memory }} \
              --execution-role-arn "${EXECUTION_ROLE_ARN}" \
              --container-definitions "$CONTAINER_DEFS" \
              --region ap-northeast-2 \
              --tags key=Name,value=${FAMILY} key=Application,value=${IMAGE_NAME} key=ManagedBy,value=github-actions \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)

            REVISION=$(echo "${TASK_DEF_ARN}" | awk -F: '{print $NF}')

            echo "âœ“ Task Definition ìƒì„± ì™„ë£Œ: ${FAMILY}:${REVISION}"
            echo "  ARN: ${TASK_DEF_ARN}"
          fi

          echo ""
          echo "TASK_DEFINITION_ARN=${TASK_DEF_ARN}" >> $GITHUB_ENV
          echo "CONTAINER_PORT=${CONTAINER_PORT}" >> $GITHUB_ENV

      - name: VPC ë° Subnet ì¡°íšŒ
        run: |
          set -euo pipefail
          REGION="ap-northeast-2"

          echo "=== VPC ë° Subnet ì¡°íšŒ ==="

          # Default VPC ì¡°íšŒ
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --region ${REGION} \
            --query 'Vpcs[0].VpcId' \
            --output text)

          # Subnet ëª©ë¡ ì¡°íšŒ (ALBëŠ” ìµœì†Œ 2ê°œ AZ í•„ìš”)
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=${VPC_ID}" \
            --region ${REGION} \
            --query 'Subnets[*].SubnetId' \
            --output text | tr '\t' ',')

          echo "âœ“ VPC: ${VPC_ID}"
          echo "âœ“ Subnets: ${SUBNET_IDS}"

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "VPC_ID=${VPC_ID}" >> $GITHUB_ENV
          echo "SUBNET_IDS=${SUBNET_IDS}" >> $GITHUB_ENV

      - name: Security Group ìƒì„±
        run: |
          set -euo pipefail
          REGION="ap-northeast-2"
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          VPC_ID="${{ env.VPC_ID }}"
          SG_NAME="${IMAGE_NAME}-alb-sg"

          echo "=== Security Group ìƒì„± ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ Security Group í™•ì¸
          SECURITY_GROUP_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=${SG_NAME}" "Name=vpc-id,Values=${VPC_ID}" \
            --region ${REGION} \
            --query 'SecurityGroups[0].GroupId' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$SECURITY_GROUP_ID"; then
            echo "âœ“ ê¸°ì¡´ Security Group ì‚¬ìš©: ${SECURITY_GROUP_ID}"
          else
            # Security Group ìƒì„±
            SECURITY_GROUP_ID=$(aws ec2 create-security-group \
              --group-name "${SG_NAME}" \
              --description "Security group for ${IMAGE_NAME} ALB" \
              --vpc-id "${VPC_ID}" \
              --region ${REGION} \
              --query 'GroupId' \
              --output text)

            # HTTP(80), HTTPS(443) ì¸ë°”ìš´ë“œ ê·œì¹™ ì¶”ê°€
            for PORT in 80 443; do
              aws ec2 authorize-security-group-ingress \
                --group-id "${SECURITY_GROUP_ID}" \
                --protocol tcp \
                --port ${PORT} \
                --cidr 0.0.0.0/0 \
                --region ${REGION} >/dev/null 2>&1 || true
            done

            echo "âœ“ Security Group ìƒì„± ì™„ë£Œ: ${SECURITY_GROUP_ID}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "SECURITY_GROUP_ID=${SECURITY_GROUP_ID}" >> $GITHUB_ENV

      - name: Target Group ìƒì„±
        run: |
          set -euo pipefail
          REGION="ap-northeast-2"
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          VPC_ID="${{ env.VPC_ID }}"
          CONTAINER_PORT="${{ env.CONTAINER_PORT }}"
          HEALTH_CHECK_PATH="${{ inputs.health_check_path }}"
          TG_NAME="${IMAGE_NAME}-tg"

          echo "=== Target Group ìƒì„± ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ Target Group í™•ì¸
          TG_ARN=$(aws elbv2 describe-target-groups \
            --names "${TG_NAME}" \
            --region ${REGION} \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$TG_ARN"; then
            echo "âœ“ ê¸°ì¡´ Target Group ì‚¬ìš©: ${TG_ARN}"
          else
            # Target Group ìƒì„±
            TG_ARN=$(aws elbv2 create-target-group \
              --name "${TG_NAME}" \
              --protocol HTTP \
              --port ${CONTAINER_PORT} \
              --vpc-id "${VPC_ID}" \
              --target-type ip \
              --health-check-path "${HEALTH_CHECK_PATH}" \
              --health-check-interval-seconds 30 \
              --health-check-timeout-seconds 5 \
              --healthy-threshold-count 2 \
              --unhealthy-threshold-count 2 \
              --region ${REGION} \
              --query 'TargetGroups[0].TargetGroupArn' \
              --output text)

            echo "âœ“ Target Group ìƒì„± ì™„ë£Œ: ${TG_ARN}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "TARGET_GROUP_ARN=${TG_ARN}" >> $GITHUB_ENV

      - name: Application Load Balancer ìƒì„±
        run: |
          set -euo pipefail
          REGION="ap-northeast-2"
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          SUBNET_IDS="${{ env.SUBNET_IDS }}"
          SECURITY_GROUP_ID="${{ env.SECURITY_GROUP_ID }}"
          ALB_NAME="${IMAGE_NAME}-alb"

          echo "=== Application Load Balancer ìƒì„± ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ ALB í™•ì¸
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --names "${ALB_NAME}" \
            --region ${REGION} \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$ALB_ARN"; then
            echo "âœ“ ê¸°ì¡´ ALB ì‚¬ìš©: ${ALB_ARN}"
          else
            # ALB ìƒì„±
            echo "ALB ìƒì„± ì¤‘..."
            ALB_ARN=$(aws elbv2 create-load-balancer \
              --name "${ALB_NAME}" \
              --subnets $(echo ${SUBNET_IDS} | tr ',' ' ') \
              --security-groups "${SECURITY_GROUP_ID}" \
              --scheme internet-facing \
              --type application \
              --ip-address-type ipv4 \
              --region ${REGION} \
              --tags Key=Name,Value=${ALB_NAME} Key=Application,Value=${IMAGE_NAME} Key=ManagedBy,Value=github-actions \
              --query 'LoadBalancers[0].LoadBalancerArn' \
              --output text)

            echo "âœ“ ALB ìƒì„± ì™„ë£Œ: ${ALB_ARN}"

            # ALB í™œì„±í™” ëŒ€ê¸° (ìµœëŒ€ 60ì´ˆ)
            echo "ALB í™œì„±í™” ëŒ€ê¸° ì¤‘..."
            for i in {1..12}; do
              STATE=$(aws elbv2 describe-load-balancers \
                --load-balancer-arns "${ALB_ARN}" \
                --region ${REGION} \
                --query 'LoadBalancers[0].State.Code' \
                --output text)

              if [ "$STATE" = "active" ]; then
                echo "âœ“ ALB í™œì„±í™” ì™„ë£Œ"
                break
              fi

              sleep 5
            done
          fi

          # ALB DNS ì´ë¦„ ì¡°íšŒ
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns "${ALB_ARN}" \
            --region ${REGION} \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "âœ“ ALB DNS: ${ALB_DNS}"

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "ALB_ARN=${ALB_ARN}" >> $GITHUB_ENV
          echo "ALB_DNS=${ALB_DNS}" >> $GITHUB_ENV

      - name: HTTPS Listener ìƒì„± (443 í¬íŠ¸)
        run: |
          set -euo pipefail
          REGION="ap-northeast-2"
          ALB_ARN="${{ env.ALB_ARN }}"
          TARGET_GROUP_ARN="${{ env.TARGET_GROUP_ARN }}"
          CERTIFICATE_ARN="${{ env.CERTIFICATE_ARN }}"

          echo "=== HTTPS Listener ìƒì„± (443) ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ HTTPS Listener í™•ì¸
          LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn "${ALB_ARN}" \
            --region ${REGION} \
            --query 'Listeners[?Port==`443`].ListenerArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$LISTENER_ARN"; then
            echo "âœ“ ê¸°ì¡´ HTTPS Listener ì‚¬ìš©: ${LISTENER_ARN}"
          else
            # HTTPS Listener ìƒì„±
            LISTENER_ARN=$(aws elbv2 create-listener \
              --load-balancer-arn "${ALB_ARN}" \
              --protocol HTTPS \
              --port 443 \
              --certificates CertificateArn=${CERTIFICATE_ARN} \
              --default-actions Type=forward,TargetGroupArn=${TARGET_GROUP_ARN} \
              --region ${REGION} \
              --query 'Listeners[0].ListenerArn' \
              --output text)

            echo "âœ“ HTTPS Listener ìƒì„± ì™„ë£Œ: ${LISTENER_ARN}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "HTTPS_LISTENER_ARN=${LISTENER_ARN}" >> $GITHUB_ENV

      - name: HTTP Listener ìƒì„± (80 â†’ 443 ë¦¬ë‹¤ì´ë ‰íŠ¸)
        run: |
          set -euo pipefail
          REGION="ap-northeast-2"
          ALB_ARN="${{ env.ALB_ARN }}"

          echo "=== HTTP Listener ìƒì„± (80 â†’ 443 ë¦¬ë‹¤ì´ë ‰íŠ¸) ==="

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # ê¸°ì¡´ HTTP Listener í™•ì¸
          HTTP_LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn "${ALB_ARN}" \
            --region ${REGION} \
            --query 'Listeners[?Port==`80`].ListenerArn' \
            --output text 2>/dev/null || echo "None")

          if is_valid "$HTTP_LISTENER_ARN"; then
            echo "âœ“ ê¸°ì¡´ HTTP Listener ì‚¬ìš©: ${HTTP_LISTENER_ARN}"
          else
            # HTTP Listener ìƒì„± (HTTPSë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸)
            HTTP_LISTENER_ARN=$(aws elbv2 create-listener \
              --load-balancer-arn "${ALB_ARN}" \
              --protocol HTTP \
              --port 80 \
              --default-actions Type=redirect,RedirectConfig="{Protocol=HTTPS,Port=443,StatusCode=HTTP_301}" \
              --region ${REGION} \
              --query 'Listeners[0].ListenerArn' \
              --output text)

            echo "âœ“ HTTP Listener ìƒì„± ì™„ë£Œ (HTTPSë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸): ${HTTP_LISTENER_ARN}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "HTTP_LISTENER_ARN=${HTTP_LISTENER_ARN}" >> $GITHUB_ENV

          # ìµœì¢… ìš”ì•½ ì¶œë ¥
          echo ""
          echo "=========================================="
          echo "âœ“ ALB ì¸í”„ë¼ êµ¬ì„± ì™„ë£Œ"
          echo "  - ALB DNS: ${{ env.ALB_DNS }}"
          echo "  - Target Group: ${{ env.TARGET_GROUP_ARN }}"
          echo "=========================================="

      - name: ECS Service ë°°í¬
        run: |
          set -euo pipefail
          REGION="ap-northeast-2"

          # ë³€ìˆ˜ ì´ˆê¸°í™”
          IMAGE_NAME="${{ needs.build-docker-image.outputs.image_name }}"
          DEPLOYMENT_PHASE="${{ inputs.deployment_phase }}"
          CLUSTER_NAME="${{ env.CLUSTER_NAME }}"
          TASK_DEFINITION_ARN="${{ env.TASK_DEFINITION_ARN }}"
          TARGET_GROUP_ARN="${{ env.TARGET_GROUP_ARN }}"
          SECURITY_GROUP_ID="${{ env.SECURITY_GROUP_ID }}"
          SUBNET_IDS="${{ env.SUBNET_IDS }}"
          CONTAINER_PORT="${{ env.CONTAINER_PORT }}"
          SERVICE_NAME="${IMAGE_NAME}-service"

          echo "=== ECS Service ë°°í¬ ==="
          echo "Service: ${SERVICE_NAME}"
          echo "Cluster: ${CLUSTER_NAME}"
          echo "Deployment Phase: ${DEPLOYMENT_PHASE}"

          # Helper í•¨ìˆ˜
          is_valid() { [ "$1" != "None" ] && [ "$1" != "null" ] && [ -n "$1" ]; }

          # Capacity Provider ì„¤ì • (alpha/beta: FARGATE_SPOT, production: FARGATE)
          if [ "$DEPLOYMENT_PHASE" = "production" ]; then
            CAPACITY_PROVIDER="FARGATE"
            FORCE_NEW_DEPLOYMENT=""
            echo "âœ“ Capacity Provider: FARGATE (On-Demand)"
          else
            CAPACITY_PROVIDER="FARGATE_SPOT"
            FORCE_NEW_DEPLOYMENT="--force-new-deployment"
            echo "âœ“ Capacity Provider: FARGATE_SPOT (latest íƒœê·¸, force deployment)"
          fi

          # ê¸°ì¡´ Service í™•ì¸
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster "${CLUSTER_NAME}" \
            --services "${SERVICE_NAME}" \
            --region ${REGION} \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "NONE")

          if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            # Service ì—…ë°ì´íŠ¸
            echo "ê¸°ì¡´ Service ì—…ë°ì´íŠ¸ ì¤‘..."
            aws ecs update-service \
              --cluster "${CLUSTER_NAME}" \
              --service "${SERVICE_NAME}" \
              --task-definition "${TASK_DEFINITION_ARN}" \
              --desired-count 1 \
              --capacity-provider-strategy capacityProvider=${CAPACITY_PROVIDER},weight=1 \
              ${FORCE_NEW_DEPLOYMENT} \
              --region ${REGION} \
              --query 'service.serviceName' \
              --output text > /dev/null

            echo "âœ“ Service ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${SERVICE_NAME}"
          else
            # Service ìƒì„±
            echo "ìƒˆ Service ìƒì„± ì¤‘..."

            # Subnet IDsë¥¼ ë°°ì—´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (ì‰¼í‘œ â†’ ê³µë°±)
            SUBNET_ARRAY=$(echo ${SUBNET_IDS} | tr ',' ' ')

            aws ecs create-service \
              --cluster "${CLUSTER_NAME}" \
              --service-name "${SERVICE_NAME}" \
              --task-definition "${TASK_DEFINITION_ARN}" \
              --desired-count 1 \
              --capacity-provider-strategy capacityProvider=${CAPACITY_PROVIDER},weight=1 \
              --network-configuration "awsvpcConfiguration={subnets=[${SUBNET_IDS}],securityGroups=[${SECURITY_GROUP_ID}],assignPublicIp=ENABLED}" \
              --load-balancers "targetGroupArn=${TARGET_GROUP_ARN},containerName=${IMAGE_NAME},containerPort=${CONTAINER_PORT}" \
              --region ${REGION} \
              --tags key=Name,value=${SERVICE_NAME} key=Application,value=${IMAGE_NAME} key=ManagedBy,value=github-actions \
              --query 'service.serviceName' \
              --output text > /dev/null

            echo "âœ“ Service ìƒì„± ì™„ë£Œ: ${SERVICE_NAME}"
          fi

          # í™˜ê²½ë³€ìˆ˜ë¡œ ì €ì¥
          echo "SERVICE_NAME=${SERVICE_NAME}" >> $GITHUB_ENV

      - name: Route 53 DNS ë ˆì½”ë“œ ìƒì„± (ig-pilot.com í˜¸ìŠ¤íŒ… ì¡´ì— ë ˆì½”ë“œ ì¶”ê°€)
        run: |
          echo "work in progress"

  ## ë°°í¬ ëª¨ë‹ˆí„°ë§: ë°°í¬ëœ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
  monitor-deployment:
    needs: deploy-infrastructure-if-necessary
    runs-on: ubuntu-latest
    environment: alpha
    permissions:
      id-token: write
      contents: read
    steps:
      - name: ECS ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
        run: |
          echo "work in progress"

      - name: ì• í”Œë¦¬ì¼€ì´ì…˜ ì •ìƒ ë°°í¬ ì—¬ë¶€ í™•ì¸
        run: |
          echo "work in progress"

      - name: ë°°í¬ ì™„ë£Œ ì•Œë¦¼
        run: |
          echo "work in progress"
